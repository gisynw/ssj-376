{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-ssj-376-spatial-database","title":"Welcome to SSJ 376 Spatial Database","text":"<p>Hi there! Welcome to my GitHub repository, where I share teaching material. I'm excited to have you here!</p>"},{"location":"#about-me","title":"About Me","text":"<p>I am a Visiting Assistant Professor (VAP) in Graduate School of Geography at Clark University. </p> <p>I hold a Ph.D. from the Department of Geospatial Information Sciences at the University of Texas at Dallas (\u5fb7\u5dde\u5927\u5b66\u8fbe\u62c9\u65af\u5206\u6821).</p>"},{"location":"#education","title":"Education","text":"<ul> <li>2019\u20132024 \u2003 Ph.D. in Geospatial Information Sciences. University of Texas at Dallas, Texas, USA</li> <li>2017\u20132019 \u2003 M.A. in Geography. Binghamton University (SUNY), New York, USA</li> <li>2012\u20132016 \u2003 B.S. in  Resource Environment and Urban-Rural Planning Management. Xi\u2019an University of Science and Technology, China</li> </ul>"},{"location":"#teaching","title":"Teaching","text":"<ul> <li>2025 \u2003  SSJ 376 Spatial Database DVLP in PRAC - Clark University</li> <li>2025 \u2003  GEOG 386 Sptial Topics: Python Programming - Clark University</li> <li>2025 \u2003  GEOG 247 Intermediate Quantitative Methods in GEOG - Clark University</li> <li>2024 \u2003  SSJ 30262 Web Mapping &amp; Open Source GIS - Clark University</li> <li>2024  \u2003 SSJ 302 Python Programming &amp; SSJ 30274 Computer PROG for GIS - Clark University</li> <li>2022  \u2003 Principles of Geospatial Information Sciences -  University of Texas at Dallas</li> <li>2021  \u2003 Methods of Quantitative Analysis in the Social and Policy Science - University of Texas at Dallas</li> </ul>"},{"location":"Content/syllabus/","title":"Syllabus Spring 2025","text":""},{"location":"Demo/Troubleshooting/","title":"Troubleshooting","text":"In\u00a0[\u00a0]: Copied!"},{"location":"Demo/Troubleshooting/#Troubleshooting","title":"Troubleshooting\u00b6","text":""},{"location":"Demo/Troubleshooting/#1.-Connection-Timeout-Experied","title":"1. Connection Timeout Experied\u00b6","text":"<p>The pgadmin can connect to server only when the server is running</p> <p>Check whether your server is running</p> <p>Windows</p> <p>Using Task Manager:</p> <ul> <li>Open Task Manager (Ctrl + Shift + Esc).</li> <li>Go to the Services tab.</li> <li>Look for a service named postgresql-x.x (where x.x is your PostgreSQL version).</li> <li>The status should be \"Running.\" If not, right-click and select Start.</li> </ul>"},{"location":"Demo/Troubleshooting/#2.-Setting-Windows-PATH-for-Postgres-tools","title":"2. Setting Windows PATH for Postgres tools\u00b6","text":"<p>Error message: 'psql' is not recognized as an internal or external command</p> <ul> <li>Choose 'Edit the system environment variables'</li> </ul> <p></p> <ul> <li>Go to the 'Advanced' tab and click on the 'Environment Variables' button at the bottom</li> </ul> <p></p> <ul> <li>Find the 'Path' variables in the System variables box, double click the 'Path' variable</li> </ul> <p></p> <ul> <li>Click on the 'New' button and add new path. If you install the PostgreSQL using default location, then your path shoud like in C:\\Program Files\\PostgreSQL\\11\\bin\\</li> </ul> <p></p>"},{"location":"Labs/Lab01/Lab01/","title":"Lab 01","text":""},{"location":"Labs/Lab04/Instructor_Lab04/","title":"Instructor Lab04","text":"<p>Due date: Thursday, Feb 20 submitted as PDF or HTML to Canvas Lab04 link. This lab counts 9 % toward your total grade.</p> <p>Objectives:</p> <ol> <li>Understand Spatial Relationships.</li> <li>Implement Subqueries.</li> </ol> <p>For each task:</p> <ol> <li>Provide the SQL Query</li> <li>Plot the output.</li> </ol> In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[2]: Copied! <pre>host = 'localhost'\ndatabase = 'test'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'test' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') In\u00a0[3]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\" In\u00a0[4]: Copied! <pre>engine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() Out[4]: <pre>['spatial_ref_sys']</pre> In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\nSELECT name, geom\nFROM ch05.subway_stations\nWHERE ST_Equals(geom, '0101000020266900002A40A25A52DE2141EBE9FA836A365141');\n\"\"\"\n\nsubway_stations = gpd.read_postgis(query, engine, geom_col='geom')\nprint(subway_stations)\nquery02 = \"\"\"\nSELECT * FROM ch05.neighborhoods\n\"\"\"\n\nall_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')\n# Plotting with different colors for RED and GREY stations\nfig, ax = plt.subplots(figsize=(10, 8))\nall_neighborhood.plot(ax=ax, color = 'none')\nsubway_stations.plot(ax=ax, color='red', label='Times Sq')\n\nplt.legend()\nplt.title('Subway Stations Colored RED and GREY')\nplt.show()\n</pre> query = \"\"\" SELECT name, geom FROM ch05.subway_stations WHERE ST_Equals(geom, '0101000020266900002A40A25A52DE2141EBE9FA836A365141'); \"\"\"  subway_stations = gpd.read_postgis(query, engine, geom_col='geom') print(subway_stations) query02 = \"\"\" SELECT * FROM ch05.neighborhoods \"\"\"  all_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom') # Plotting with different colors for RED and GREY stations fig, ax = plt.subplots(figsize=(10, 8)) all_neighborhood.plot(ax=ax, color = 'none') subway_stations.plot(ax=ax, color='red', label='Times Sq')  plt.legend() plt.title('Subway Stations Colored RED and GREY') plt.show() <pre>       name                            geom\n0  Times Sq  POINT (585513.177 4512170.062)\n</pre> In\u00a0[31]: Copied! <pre>query = \"\"\"\nSELECT street.name, nbh.name, nbh.boroname, street.geom\nFROM ch05.streets AS street, ch05.neighborhoods AS nbh\nWHERE street.name = '5th Ave' AND ST_Intersects(street.geom, nbh.geom);\n\"\"\"\n\nsubway_stations = gpd.read_postgis(query, engine, geom_col='geom')\nprint(subway_stations)\nquery02 = \"\"\"\nSELECT * FROM ch05.neighborhoods\n\"\"\"\n\nall_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')\n# Plotting with different colors for RED and GREY stations\nfig, ax = plt.subplots(figsize=(10, 8))\nall_neighborhood.plot(ax=ax, color = 'none')\nall_neighborhood[all_neighborhood['boroname'] == 'Manhattan'].plot(ax=ax, color = 'grey')\nsubway_stations.plot(ax=ax, color='red', label='5th Ave')\n\nplt.legend()\nplt.title('Subway Stations Colored RED and GREY')\nplt.show()\n</pre> query = \"\"\" SELECT street.name, nbh.name, nbh.boroname, street.geom FROM ch05.streets AS street, ch05.neighborhoods AS nbh WHERE street.name = '5th Ave' AND ST_Intersects(street.geom, nbh.geom); \"\"\"  subway_stations = gpd.read_postgis(query, engine, geom_col='geom') print(subway_stations) query02 = \"\"\" SELECT * FROM ch05.neighborhoods \"\"\"  all_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom') # Plotting with different colors for RED and GREY stations fig, ax = plt.subplots(figsize=(10, 8)) all_neighborhood.plot(ax=ax, color = 'none') all_neighborhood[all_neighborhood['boroname'] == 'Manhattan'].plot(ax=ax, color = 'grey') subway_stations.plot(ax=ax, color='red', label='5th Ave')  plt.legend() plt.title('Subway Stations Colored RED and GREY') plt.show() <pre>       name               name   boroname  \\\n0   5th Ave             Harlem  Manhattan   \n1   5th Ave        East Harlem  Manhattan   \n2   5th Ave      The Rockaways     Queens   \n3   5th Ave       Throggs Neck  The Bronx   \n4   5th Ave       Throggs Neck  The Bronx   \n5   5th Ave       Throggs Neck  The Bronx   \n6   5th Ave       Throggs Neck  The Bronx   \n7   5th Ave        Sunset Park   Brooklyn   \n8   5th Ave          Bay Ridge   Brooklyn   \n9   5th Ave          Greenwood   Brooklyn   \n10  5th Ave         Park Slope   Brooklyn   \n11  5th Ave  Greenwich Village  Manhattan   \n12  5th Ave           Gramercy  Manhattan   \n13  5th Ave        Murray Hill  Manhattan   \n14  5th Ave           Gramercy  Manhattan   \n15  5th Ave            Midtown  Manhattan   \n16  5th Ave    Upper East Side  Manhattan   \n17  5th Ave      Carnegie Hill  Manhattan   \n18  5th Ave          Yorkville  Manhattan   \n19  5th Ave        East Harlem  Manhattan   \n20  5th Ave         Fort Green   Brooklyn   \n21  5th Ave         Park Slope   Brooklyn   \n\n                                                 geom  \n0   MULTILINESTRING ((589177.305 4517730.877, 5892...  \n1   MULTILINESTRING ((589177.305 4517730.877, 5892...  \n2   MULTILINESTRING ((590747.652 4490142.689, 5908...  \n3   MULTILINESTRING ((600340.383 4519875.690, 6003...  \n4   MULTILINESTRING ((600424.146 4519949.441, 6004...  \n5   MULTILINESTRING ((600492.223 4519930.492, 6004...  \n6   MULTILINESTRING ((600523.844 4519713.414, 6005...  \n7   MULTILINESTRING ((585678.912 4502527.147, 5856...  \n8   MULTILINESTRING ((585678.912 4502527.147, 5856...  \n9   MULTILINESTRING ((585678.912 4502527.147, 5856...  \n10  MULTILINESTRING ((585678.912 4502527.147, 5856...  \n11  MULTILINESTRING ((585336.793 4510610.386, 5853...  \n12  MULTILINESTRING ((585336.793 4510610.386, 5853...  \n13  MULTILINESTRING ((589025.202 4517449.706, 5889...  \n14  MULTILINESTRING ((589025.202 4517449.706, 5889...  \n15  MULTILINESTRING ((589025.202 4517449.706, 5889...  \n16  MULTILINESTRING ((589025.202 4517449.706, 5889...  \n17  MULTILINESTRING ((589025.202 4517449.706, 5889...  \n18  MULTILINESTRING ((589025.202 4517449.706, 5889...  \n19  MULTILINESTRING ((589025.202 4517449.706, 5889...  \n20  MULTILINESTRING ((586537.308 4504128.237, 5865...  \n21  MULTILINESTRING ((586537.308 4504128.237, 5865...  \n</pre> In\u00a0[38]: Copied! <pre>query = \"\"\"\nSELECT street.name, nbh.name, nbh.boroname, street.geom\nFROM ch05.streets AS street, ch05.neighborhoods AS nbh\nWHERE nbh.boroname = 'Staten Island' AND nbh.name = 'Howland Hook' AND ST_Crosses(street.geom, nbh.geom);\n\"\"\"\nsubway_stations = gpd.read_postgis(query, engine, geom_col='geom')\nprint(subway_stations)\n\nquery02 = \"\"\"\nSELECT * FROM ch05.neighborhoods\n\"\"\"\n\nall_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')\n# Plotting with different colors for RED and GREY stations\nfig, ax = plt.subplots(figsize=(10, 8))\nall_neighborhood.plot(ax=ax, color = 'none')\nall_neighborhood[all_neighborhood['name'] == 'Howland Hook'].plot(ax=ax, color = 'grey')\nsubway_stations.plot(ax=ax, color='red', label='streets')\n\nplt.legend()\nplt.title('Subway Stations Colored RED and GREY')\nplt.show()\n</pre> query = \"\"\" SELECT street.name, nbh.name, nbh.boroname, street.geom FROM ch05.streets AS street, ch05.neighborhoods AS nbh WHERE nbh.boroname = 'Staten Island' AND nbh.name = 'Howland Hook' AND ST_Crosses(street.geom, nbh.geom); \"\"\" subway_stations = gpd.read_postgis(query, engine, geom_col='geom') print(subway_stations)  query02 = \"\"\" SELECT * FROM ch05.neighborhoods \"\"\"  all_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom') # Plotting with different colors for RED and GREY stations fig, ax = plt.subplots(figsize=(10, 8)) all_neighborhood.plot(ax=ax, color = 'none') all_neighborhood[all_neighborhood['name'] == 'Howland Hook'].plot(ax=ax, color = 'grey') subway_stations.plot(ax=ax, color='red', label='streets')  plt.legend() plt.title('Subway Stations Colored RED and GREY') plt.show() <pre>                 name          name       boroname  \\\n0            Ewing St  Howland Hook  Staten Island   \n1       Goethals Rd N  Howland Hook  Staten Island   \n2   Staten Island Pky  Howland Hook  Staten Island   \n3                None  Howland Hook  Staten Island   \n4                None  Howland Hook  Staten Island   \n5          Meeker Ave  Howland Hook  Staten Island   \n6          Forest Ave  Howland Hook  Staten Island   \n7                None  Howland Hook  Staten Island   \n8            Lisk Ave  Howland Hook  Staten Island   \n9   Staten Island Pky  Howland Hook  Staten Island   \n10       Richmond Ter  Howland Hook  Staten Island   \n11          Cable Way  Howland Hook  Staten Island   \n12       Arlington Pl  Howland Hook  Staten Island   \n13               None  Howland Hook  Staten Island   \n14         Forest Ave  Howland Hook  Staten Island   \n\n                                                 geom  \n0   MULTILINESTRING ((570359.071 4497138.065, 5703...  \n1   MULTILINESTRING ((571327.865 4496512.841, 5711...  \n2   MULTILINESTRING ((570651.816 4496869.909, 5705...  \n3   MULTILINESTRING ((569522.806 4497490.657, 5695...  \n4   MULTILINESTRING ((569384.647 4497592.055, 5694...  \n5   MULTILINESTRING ((569474.149 4497414.991, 5696...  \n6   MULTILINESTRING ((568801.068 4498030.691, 5687...  \n7   MULTILINESTRING ((570327.915 4497031.742, 5702...  \n8   MULTILINESTRING ((570381.261 4497260.390, 5704...  \n9   MULTILINESTRING ((579529.834 4494973.124, 5794...  \n10  MULTILINESTRING ((573680.802 4498865.410, 5736...  \n11  MULTILINESTRING ((570495.201 4498028.243, 5703...  \n12  MULTILINESTRING ((570672.331 4498667.034, 5706...  \n13  MULTILINESTRING ((569151.165 4497727.439, 5693...  \n14  MULTILINESTRING ((577051.621 4498116.230, 5769...  \n</pre> In\u00a0[43]: Copied! <pre>query = \"\"\"\nSELECT streets.name, streets.geom\nFROM ch05.streets AS streets\nWHERE ST_Overlaps(streets.geom, streets.geom);\n\"\"\"\nsubway_stations = gpd.read_postgis(query, engine, geom_col='geom')\nprint(subway_stations)\n\nquery02 = \"\"\"\nSELECT * FROM ch05.neighborhoods\n\"\"\"\n\nall_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')\n# Plotting with different colors for RED and GREY stations\nfig, ax = plt.subplots(figsize=(10, 8))\nall_neighborhood.plot(ax=ax, color = 'none')\nsubway_stations.plot(ax=ax, color='red', label='streets')\n\nplt.legend()\nplt.title('Subway Stations Colored RED and GREY')\nplt.show()\n</pre> query = \"\"\" SELECT streets.name, streets.geom FROM ch05.streets AS streets WHERE ST_Overlaps(streets.geom, streets.geom); \"\"\" subway_stations = gpd.read_postgis(query, engine, geom_col='geom') print(subway_stations)  query02 = \"\"\" SELECT * FROM ch05.neighborhoods \"\"\"  all_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom') # Plotting with different colors for RED and GREY stations fig, ax = plt.subplots(figsize=(10, 8)) all_neighborhood.plot(ax=ax, color = 'none') subway_stations.plot(ax=ax, color='red', label='streets')  plt.legend() plt.title('Subway Stations Colored RED and GREY') plt.show() <pre>C:\\Users\\wlicc\\AppData\\Local\\Temp\\ipykernel_41624\\3569129261.py:17: UserWarning: The GeoDataFrame you are attempting to plot is empty. Nothing has been displayed.\n  subway_stations.plot(ax=ax, color='red', label='streets')\nNo artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n</pre> <pre>Empty GeoDataFrame\nColumns: [name, geom]\nIndex: []\n</pre> In\u00a0[48]: Copied! <pre>query = \"\"\"\nSELECT nbh.name, subway.name, subway.geom\nFROM ch05.neighborhoods AS nbh, ch05.subway_stations AS subway\nWHERE nbh.name = 'Sunny Side' AND ST_Within(subway.geom, nbh.geom);\n\"\"\"\nsubway_stations = gpd.read_postgis(query, engine, geom_col='geom')\nprint(subway_stations)\n\nquery02 = \"\"\"\nSELECT * FROM ch05.neighborhoods\n\"\"\"\n\nall_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')\n# Plotting with different colors for RED and GREY stations\nfig, ax = plt.subplots(figsize=(10, 8))\nall_neighborhood.plot(ax=ax, color = 'none')\nsubway_stations.plot(ax=ax, color='red', label='subway station')\n\nplt.legend()\nplt.title('Subway Stations Colored RED and GREY')\nplt.show()\n</pre> query = \"\"\" SELECT nbh.name, subway.name, subway.geom FROM ch05.neighborhoods AS nbh, ch05.subway_stations AS subway WHERE nbh.name = 'Sunny Side' AND ST_Within(subway.geom, nbh.geom); \"\"\" subway_stations = gpd.read_postgis(query, engine, geom_col='geom') print(subway_stations)  query02 = \"\"\" SELECT * FROM ch05.neighborhoods \"\"\"  all_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom') # Plotting with different colors for RED and GREY stations fig, ax = plt.subplots(figsize=(10, 8)) all_neighborhood.plot(ax=ax, color = 'none') subway_stations.plot(ax=ax, color='red', label='subway station')  plt.legend() plt.title('Subway Stations Colored RED and GREY') plt.show() <pre>         name               name                            geom\n0  Sunny Side        Vernon Blvd  POINT (588321.305 4510718.315)\n1  Sunny Side  Hunters Point Ave  POINT (588703.135 4510660.519)\n2  Sunny Side            21st St  POINT (588763.471 4510941.005)\n3  Sunny Side            45th Rd  POINT (589025.590 4511122.231)\n4  Sunny Side            23rd St  POINT (589062.359 4511280.549)\n5  Sunny Side           Court Sq  POINT (589156.160 4511154.888)\n6  Sunny Side            46th St  POINT (591292.185 4510806.902)\n7  Sunny Side            40th St  POINT (590821.194 4510871.656)\n8  Sunny Side            33rd St  POINT (590193.801 4510958.492)\n</pre> In\u00a0[63]: Copied! <pre>query = \"\"\"\nSELECT streets.name, subway.name, ST_Distance(streets.geom, subway.geom), streets.geom\nFROM ch05.streets AS streets, ch05.subway_stations AS subway\nWHERE subway.alt_name = 'Yankee Stadium' AND ST_Dwithin(streets.geom, subway.geom, 50);\n\"\"\"\nsubway_stations = gpd.read_postgis(query, engine, geom_col='geom')\nprint(subway_stations)\n\nquery02 = \"\"\"\nSELECT * FROM ch05.neighborhoods\n\"\"\"\n\nquery03 = \"\"\"\nSELECT * FROM ch05.subway_stations AS subway WHERE subway.alt_name = 'Yankee Stadium';\n\"\"\"\n\nall_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')\n\nyankee = gpd.read_postgis(query03, engine, geom_col='geom')\n# Plotting with different colors for RED and GREY stations\nfig, ax = plt.subplots(figsize=(10, 8))\nall_neighborhood.plot(ax=ax, color = 'none')\nsubway_stations.plot(ax=ax, color='red', label='street')\nyankee.plot(ax=ax, color='black', label='Yankee Stadium')\n\nplt.legend()\nplt.title('Subway Stations Colored RED and GREY')\nplt.show()\n</pre> query = \"\"\" SELECT streets.name, subway.name, ST_Distance(streets.geom, subway.geom), streets.geom FROM ch05.streets AS streets, ch05.subway_stations AS subway WHERE subway.alt_name = 'Yankee Stadium' AND ST_Dwithin(streets.geom, subway.geom, 50); \"\"\" subway_stations = gpd.read_postgis(query, engine, geom_col='geom') print(subway_stations)  query02 = \"\"\" SELECT * FROM ch05.neighborhoods \"\"\"  query03 = \"\"\" SELECT * FROM ch05.subway_stations AS subway WHERE subway.alt_name = 'Yankee Stadium'; \"\"\"  all_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')  yankee = gpd.read_postgis(query03, engine, geom_col='geom') # Plotting with different colors for RED and GREY stations fig, ax = plt.subplots(figsize=(10, 8)) all_neighborhood.plot(ax=ax, color = 'none') subway_stations.plot(ax=ax, color='red', label='street') yankee.plot(ax=ax, color='black', label='Yankee Stadium')  plt.legend() plt.title('Subway Stations Colored RED and GREY') plt.show() <pre>         name      name  st_distance  \\\n0   River Ave  161st St     0.356185   \n1  E 161st St  161st St    18.104581   \n\n                                                geom  \n0  MULTILINESTRING ((590189.688 4518806.333, 5901...  \n1  MULTILINESTRING ((590228.547 4520431.887, 5903...  \n</pre> In\u00a0[7]: Copied! <pre>query = \"\"\"\nSELECT name, color, geom\nFROM ch05.subway_stations\nWHERE color IN ('RED', 'GREY');\n\"\"\"\n\nsubway_stations = gpd.read_postgis(query, engine, geom_col='geom')\n\nquery02 = \"\"\"\nSELECT * FROM ch05.neighborhoods\n\"\"\"\n\nall_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')\n# Plotting with different colors for RED and GREY stations\nfig, ax = plt.subplots(figsize=(10, 8))\nall_neighborhood.plot(ax=ax, color = 'none')\nsubway_stations[subway_stations['color'] == 'RED'].plot(ax=ax, color='red', label='RED Stations')\nsubway_stations[subway_stations['color'] == 'GREY'].plot(ax=ax, color='grey', label='GREY Stations')\n\nplt.legend()\nplt.title('Subway Stations Colored RED and GREY')\nplt.show()\n</pre> query = \"\"\" SELECT name, color, geom FROM ch05.subway_stations WHERE color IN ('RED', 'GREY'); \"\"\"  subway_stations = gpd.read_postgis(query, engine, geom_col='geom')  query02 = \"\"\" SELECT * FROM ch05.neighborhoods \"\"\"  all_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom') # Plotting with different colors for RED and GREY stations fig, ax = plt.subplots(figsize=(10, 8)) all_neighborhood.plot(ax=ax, color = 'none') subway_stations[subway_stations['color'] == 'RED'].plot(ax=ax, color='red', label='RED Stations') subway_stations[subway_stations['color'] == 'GREY'].plot(ax=ax, color='grey', label='GREY Stations')  plt.legend() plt.title('Subway Stations Colored RED and GREY') plt.show() In\u00a0[7]: Copied! <pre>query = \"\"\"\nSELECT subway.name, street.geom\nFROM ch05.subway subway, ch05.streets street\nWHERE ST_Crosses(ST_Buffer(subway.geom, 100), street.geom);\n\"\"\"\n\nall_subway_query = \"\"\" SELECT * FROM ch05.subway\n\"\"\"\noverlapping_service_areas = gpd.read_postgis(query, engine, geom_col='geom')\nall_subway = gpd.read_postgis(all_subway_query, engine, geom_col='geom')\n# Plotting service areas with no fill color to highlight overlaps\nfig, ax = plt.subplots(figsize=(10, 8))\n\nall_subway.plot(ax = ax, color = 'black')\noverlapping_service_areas.plot(ax=ax, facecolor='none', edgecolor='grey')\n\nplt.title('Streets within Service Area of Subway Station (100m)')\nplt.show()\n</pre> query = \"\"\" SELECT subway.name, street.geom FROM ch05.subway subway, ch05.streets street WHERE ST_Crosses(ST_Buffer(subway.geom, 100), street.geom); \"\"\"  all_subway_query = \"\"\" SELECT * FROM ch05.subway \"\"\" overlapping_service_areas = gpd.read_postgis(query, engine, geom_col='geom') all_subway = gpd.read_postgis(all_subway_query, engine, geom_col='geom') # Plotting service areas with no fill color to highlight overlaps fig, ax = plt.subplots(figsize=(10, 8))  all_subway.plot(ax = ax, color = 'black') overlapping_service_areas.plot(ax=ax, facecolor='none', edgecolor='grey')  plt.title('Streets within Service Area of Subway Station (100m)') plt.show() In\u00a0[11]: Copied! <pre>query = \"\"\"\nSELECT name, ST_Centroid(geom) AS geom\nFROM ch05.neighborhoods;\n\"\"\"\n\nneighborhood_centroids = gpd.read_postgis(query, engine, geom_col='geom')\n\n# Plot neighborhoods and their centroids\nneighborhoods = gpd.read_postgis(\"SELECT * FROM ch05.neighborhoods\", engine, geom_col='geom')\n\nfig, ax = plt.subplots(figsize=(10, 8))\nneighborhoods.plot(ax=ax, edgecolor='black', facecolor='none')\nneighborhood_centroids.plot(ax=ax, color='red', marker='o', label='Centroids')\n\nplt.legend()\nplt.title('Neighborhoods and Their Centroids')\nplt.show()\n</pre> query = \"\"\" SELECT name, ST_Centroid(geom) AS geom FROM ch05.neighborhoods; \"\"\"  neighborhood_centroids = gpd.read_postgis(query, engine, geom_col='geom')  # Plot neighborhoods and their centroids neighborhoods = gpd.read_postgis(\"SELECT * FROM ch05.neighborhoods\", engine, geom_col='geom')  fig, ax = plt.subplots(figsize=(10, 8)) neighborhoods.plot(ax=ax, edgecolor='black', facecolor='none') neighborhood_centroids.plot(ax=ax, color='red', marker='o', label='Centroids')  plt.legend() plt.title('Neighborhoods and Their Centroids') plt.show() In\u00a0[19]: Copied! <pre>query = \"\"\"SELECT nbh.name AS neighborhood, subway.name AS nearest_station, subway.geom\nFROM ch05.neighborhoods AS nbh, ch05.subway AS subway\nWHERE ST_Distance(ST_Centroid(nbh.geom), subway.geom) = (\n    SELECT MIN(ST_Distance(ST_Centroid(nbh.geom), s.geom))\n    FROM ch05.subway AS s\n);\"\"\"\n\nneighborhoods = gpd.read_postgis(\"SELECT * FROM ch05.neighborhoods\", engine, geom_col='geom')\nnearest_subway = gpd.read_postgis(query, engine)\n\n\nfig, ax = plt.subplots(figsize=(10, 8))\nneighborhoods.plot(ax=ax, edgecolor='black', facecolor='none')\nnearest_subway.plot(ax=ax, color='red', marker='o', label='Centroids')\n</pre> query = \"\"\"SELECT nbh.name AS neighborhood, subway.name AS nearest_station, subway.geom FROM ch05.neighborhoods AS nbh, ch05.subway AS subway WHERE ST_Distance(ST_Centroid(nbh.geom), subway.geom) = (     SELECT MIN(ST_Distance(ST_Centroid(nbh.geom), s.geom))     FROM ch05.subway AS s );\"\"\"  neighborhoods = gpd.read_postgis(\"SELECT * FROM ch05.neighborhoods\", engine, geom_col='geom') nearest_subway = gpd.read_postgis(query, engine)   fig, ax = plt.subplots(figsize=(10, 8)) neighborhoods.plot(ax=ax, edgecolor='black', facecolor='none') nearest_subway.plot(ax=ax, color='red', marker='o', label='Centroids')  Out[19]: <pre>&lt;Axes: &gt;</pre>"},{"location":"Labs/Lab04/Instructor_Lab04/#Lab-04","title":"Lab 04\u00b6","text":""},{"location":"Labs/Lab04/Instructor_Lab04/#In-class-Practice","title":"In-class Practice\u00b6","text":""},{"location":"Labs/Lab04/Instructor_Lab04/#1.-ST_Equals","title":"1. ST_Equals\u00b6","text":""},{"location":"Labs/Lab04/Instructor_Lab04/#Task-1","title":"Task 1\u00b6","text":"<p>Use <code>ST_Equals()</code> to find the <code>name</code> of the subway station where its geometry is <code>0101000020266900002A40A25A52DE2141EBE9FA836A365141</code></p>"},{"location":"Labs/Lab04/Instructor_Lab04/#2.-ST_Intersects-/-ST_Disjoint()","title":"2. ST_Intersects / ST_Disjoint()\u00b6","text":""},{"location":"Labs/Lab04/Instructor_Lab04/#Task-2","title":"Task 2\u00b6","text":"<p>Please the neighborhoods that intersect with <code>5th Ave</code> by using <code>ST_Intersects</code>; highlight the street in red and plot the neighborhood</p>"},{"location":"Labs/Lab04/Instructor_Lab04/#3.-ST_Crosses()","title":"3. ST_Crosses()\u00b6","text":""},{"location":"Labs/Lab04/Instructor_Lab04/#Task-3","title":"Task 3\u00b6","text":"<p>Please find streets cross <code>Howland Hook</code> in Staten Island; highlight the streets in red, plot the neighborhoods, and grey out <code>Howland Hook</code></p>"},{"location":"Labs/Lab04/Instructor_Lab04/#4.-ST_Overlaps()","title":"4. ST_Overlaps()\u00b6","text":""},{"location":"Labs/Lab04/Instructor_Lab04/#Task-4","title":"Task 4\u00b6","text":"<p>Check out any overlapping streets exist</p>"},{"location":"Labs/Lab04/Instructor_Lab04/#5.-ST_Touches()","title":"5. ST_Touches()\u00b6","text":""},{"location":"Labs/Lab04/Instructor_Lab04/#6.-ST_Within()-and-ST_contains()","title":"6. ST_Within() and ST_contains()\u00b6","text":""},{"location":"Labs/Lab04/Instructor_Lab04/#Task-5","title":"Task 5\u00b6","text":"<p>Please find out and plot the subway stations within <code>Sunny Side</code>, <code>Queens</code></p>"},{"location":"Labs/Lab04/Instructor_Lab04/#6.-ST_Distance-/-ST_DWithin","title":"6. ST_Distance / ST_DWithin\u00b6","text":""},{"location":"Labs/Lab04/Instructor_Lab04/#Task-6","title":"Task 6\u00b6","text":"<p>Find the street that are within 50m of the subway station its <code>alt_name</code> is <code>Yankee Stadium</code>, and calculate their distance</p>"},{"location":"Labs/Lab04/Instructor_Lab04/#Task-1","title":"Task 1\u00b6","text":"<p>Select subway stations with the colors RED and GREY, then plot them in two different colors on the map.</p>"},{"location":"Labs/Lab04/Instructor_Lab04/#Task-2:-ST_Crosses","title":"Task 2: ST_Crosses\u00b6","text":"<p>Using ST_Crosses to identify the streets that cross with the 100 m buffer around each station.</p>"},{"location":"Labs/Lab04/Instructor_Lab04/#Task-3:-ST_Centroid","title":"Task 3: ST_Centroid\u00b6","text":"<p>Calculate the centroid of each neighborhood polygon using ST_Centroid and visualize them on the map.</p>"},{"location":"Labs/Lab04/Instructor_Lab04/#Task-4.-Nearest-subway-station-to-each-centroid","title":"Task 4. Nearest subway station to each centroid\u00b6","text":"<p>Use these centroids to find the subway station closest to each neighborhood center.</p> <p>ST_Centroid</p> <p>ST_Distance</p> <p>MIN(ST_Distance()): The subquery is looking for the minimum distance between the neighborhood's centroid and all subway stations.</p>"},{"location":"Labs/Lab04/Student_Lab04/","title":"Lab 04","text":"Lab 04: Spatial Relationship      <p>Due date: Thursday, Feb 20 submitted as PDF or HTML to Canvas Lab04 link. This lab counts 9 % toward your total grade.</p> <p>Objectives:</p> <ol> <li>Understand Spatial Relationships.</li> <li>Implement Subqueries.</li> </ol> <p>For each task:</p> <ol> <li>Provide the SQL Query</li> <li>Plot the output.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>host = 'localhost'\ndatabase = 'Your database'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'Your database' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') In\u00a0[\u00a0]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\" In\u00a0[\u00a0]: Copied! <pre>engine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\nSELECT __________\nFROM _________\nWHERE ________;\n\"\"\"\n\nsubway_stations = gpd.read_postgis(query, engine, geom_col='geom')\nprint(subway_stations)\n\nquery02 = \"\"\"\n________________\n\"\"\"\n\nall_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')\n\n\n# Plotting  all_neighborhood as the background, and pinpoint the station\nfig, ax = plt.subplots(figsize=(10, 8))\nall_neighborhood.plot(ax=ax, color = 'none')\nsubway_stations.plot(ax=ax, color='', label='')\n\nplt.legend()\nplt.title('')\nplt.show()\n</pre> query = \"\"\" SELECT __________ FROM _________ WHERE ________; \"\"\"  subway_stations = gpd.read_postgis(query, engine, geom_col='geom') print(subway_stations)  query02 = \"\"\" ________________ \"\"\"  all_neighborhood = gpd.read_postgis(query02, engine, geom_col='geom')   # Plotting  all_neighborhood as the background, and pinpoint the station fig, ax = plt.subplots(figsize=(10, 8)) all_neighborhood.plot(ax=ax, color = 'none') subway_stations.plot(ax=ax, color='', label='')  plt.legend() plt.title('') plt.show() In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\nSELECT __________\nFROM ch05.streets AS street, ch05.neighborhoods AS nbh\nWHERE ___________;\n\"\"\"\n</pre> query = \"\"\" SELECT __________ FROM ch05.streets AS street, ch05.neighborhoods AS nbh WHERE ___________; \"\"\" In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\nSELECT _________________\nFROM _________________\nWHERE _____________________________;\n\"\"\"\n</pre> query = \"\"\" SELECT _________________ FROM _________________ WHERE _____________________________; \"\"\" In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\nSELECT _________\nFROM _________\nJOIN __________\nON _________\nAND __________;\n\"\"\"\n</pre> query = \"\"\" SELECT _________ FROM _________ JOIN __________ ON _________ AND __________; \"\"\" In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\n\n\"\"\"\n</pre> query = \"\"\"  \"\"\" In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\n\n\"\"\"\n</pre> query = \"\"\"  \"\"\" In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\n\n\"\"\"\n</pre> query = \"\"\"  \"\"\" In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\n\n\"\"\"\n</pre> query = \"\"\"  \"\"\"  In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\n\n\"\"\"\n</pre> query = \"\"\"  \"\"\"  In\u00a0[\u00a0]: Copied! <pre>query = \"\"\"\n\n\"\"\"\n</pre> query = \"\"\"  \"\"\""},{"location":"Labs/Lab04/Student_Lab04/#In-class-Practice","title":"In-class Practice\u00b6","text":""},{"location":"Labs/Lab04/Student_Lab04/#1.-ST_Equals","title":"1. ST_Equals\u00b6","text":""},{"location":"Labs/Lab04/Student_Lab04/#Task-1","title":"Task 1\u00b6","text":"<p>Use <code>ST_Equals()</code> to find the <code>name</code> of the subway station where its geometry is <code>0101000020266900002A40A25A52DE2141EBE9FA836A365141</code></p>"},{"location":"Labs/Lab04/Student_Lab04/#2.-ST_Intersects-/-ST_Disjoint()","title":"2. ST_Intersects / ST_Disjoint()\u00b6","text":""},{"location":"Labs/Lab04/Student_Lab04/#Task-2","title":"Task 2\u00b6","text":"<p>Please find neighborhoods that intersect with <code>5th Ave</code> by using <code>ST_Intersects</code>; highlight the street in red and plot the neighborhood</p>"},{"location":"Labs/Lab04/Student_Lab04/#3.-ST_Crosses()","title":"3. ST_Crosses()\u00b6","text":""},{"location":"Labs/Lab04/Student_Lab04/#Task-3","title":"Task 3\u00b6","text":"<p>Please find streets that cross <code>Howland Hook</code> in Staten Island; highlight the streets in red, plot the neighborhoods, and grey out <code>Howland Hook</code></p>"},{"location":"Labs/Lab04/Student_Lab04/#4.-ST_Overlaps()","title":"4. ST_Overlaps()\u00b6","text":""},{"location":"Labs/Lab04/Student_Lab04/#Task-4","title":"Task 4\u00b6","text":"<p>Check if any overlapping streets exist</p>"},{"location":"Labs/Lab04/Student_Lab04/#5.-ST_Touches()","title":"5. ST_Touches()\u00b6","text":""},{"location":"Labs/Lab04/Student_Lab04/#6.-ST_Within()-and-ST_contains()","title":"6. ST_Within() and ST_contains()\u00b6","text":""},{"location":"Labs/Lab04/Student_Lab04/#Task-5","title":"Task 5\u00b6","text":"<p>Please find out and plot the subway stations within <code>Sunny Side</code>, <code>Queens</code></p>"},{"location":"Labs/Lab04/Student_Lab04/#6.-ST_Distance-/-ST_DWithin","title":"6. ST_Distance / ST_DWithin\u00b6","text":""},{"location":"Labs/Lab04/Student_Lab04/#Task-6","title":"Task 6\u00b6","text":"<p>Find the street that are within 50m of the subway station its <code>alt_name</code> is <code>Yankee Stadium</code>, and calculate their distance</p>"},{"location":"Labs/Lab04/Student_Lab04/#Task-1","title":"Task 1\u00b6","text":"<p>Select subway stations with the colors RED and GREY, then plot them in two different colors on the map.</p>"},{"location":"Labs/Lab04/Student_Lab04/#Task-2:-ST_Crosses","title":"Task 2: ST_Crosses\u00b6","text":"<p>Using ST_Crosses to identify the streets that cross with the 100 m buffer around each station.</p>"},{"location":"Labs/Lab04/Student_Lab04/#Task-3:-ST_Centroid","title":"Task 3: ST_Centroid\u00b6","text":"<p>Calculate the centroid of each neighborhood polygon using ST_Centroid and visualize them on the map.</p>"},{"location":"Labs/Lab04/Student_Lab04/#Task-4.-Nearest-subway-station-to-each-centroid","title":"Task 4. Nearest subway station to each centroid\u00b6","text":"<p>Use these centroids to find the subway station closest to each neighborhood center.</p> <p>ST_Centroid</p> <p>ST_Distance</p> <p>MIN(ST_Distance()): The subquery is looking for the minimum distance between the neighborhood's centroid and all subway stations.</p>"},{"location":"Labs/Lab05/Instructor_Lab05/","title":"Instructor Lab05","text":"In\u00a0[8]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[9]: Copied! <pre>host = 'localhost'\ndatabase = 'spatial'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatial' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') In\u00a0[10]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\" In\u00a0[11]: Copied! <pre>engine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() Out[11]: <pre>['spatial_ref_sys']</pre> <ol> <li>Find airports that have fewer than three navigation aids within 1000 kilometers. These airports may require additional navigation support.</li> </ol> In\u00a0[29]: Copied! <pre>text_fewer = \"\"\"\nSELECT airport.name AS airport_name,\n       COUNT(nav.name) AS nearby_nav_count,\n       airport.geog AS geom\nFROM ch09.airports AS airport\nLEFT JOIN ch09.navaids AS nav\nON ST_DWithin(airport.geog, nav.geog, 1000000)  -- 50 km radius\nGROUP BY airport.name, geom\nHAVING COUNT(nav.name) &lt; 3;\n\"\"\"\n</pre> text_fewer = \"\"\" SELECT airport.name AS airport_name,        COUNT(nav.name) AS nearby_nav_count,        airport.geog AS geom FROM ch09.airports AS airport LEFT JOIN ch09.navaids AS nav ON ST_DWithin(airport.geog, nav.geog, 1000000)  -- 50 km radius GROUP BY airport.name, geom HAVING COUNT(nav.name) &lt; 3; \"\"\" In\u00a0[30]: Copied! <pre>airport_fewer = gpd.read_postgis(text_fewer, con=engine)\n\nprint(len(airport_fewer.index))\n\nfig, ax = plt.subplots(figsize=(12, 10))\nairport_fewer.plot(ax=ax, color = 'grey')\n</pre> airport_fewer = gpd.read_postgis(text_fewer, con=engine)  print(len(airport_fewer.index))  fig, ax = plt.subplots(figsize=(12, 10)) airport_fewer.plot(ax=ax, color = 'grey') Out[30]: <pre>&lt;Axes: &gt;</pre>"},{"location":"Labs/Lab05/Instructor_Lab05/#Lab-05","title":"Lab 05\u00b6","text":""},{"location":"Labs/Lab05/Instructor_Lab05/#Exercise-1","title":"Exercise 1\u00b6","text":""},{"location":"Labs/Practice01/Practice01_DynamicSQL/","title":"Practice01 DynamicSQL","text":"Practice 01: Dynamic SQL: Function      In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[4]: Copied! <pre>host = 'localhost'\ndatabase = 'spatial'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatial' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') In\u00a0[5]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n\nengine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"  engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() Out[5]: <pre>['spatial_ref_sys']</pre> <p>Task 05. Modify the given function dynamic_subway_filter (Example 08 in Lecture) to filter data using ST_Intersects(). The two tables involved are ch05.streets and ch05.neighborhoods, with the filtering criterion based on the \u2018name\u2019 column. Select neighborhoods based on the chosen street name from ch05.streets. The street\u2019s name is \u20187th Ave\u2019.</p> <p>Provide the SQL and Screenshot of your map.</p> In\u00a0[6]: Copied! <pre>function_sql = \"\"\"\nCREATE OR REPLACE FUNCTION dynamic_subway_filter(\n    schema_name TEXT,   -- Schema name\n    table_name TEXT,    -- Table name\n\n\tschema_name02 TEXT,\n\ttable_name02 TEXT, \n\t\n    column_name TEXT, -- Column name to filter\n    streetName TEXT -- Value to filter by\n)\nRETURNS TABLE (\n    name character varying(64),\n\tgeom geometry(MultiPolygon,26918))\n\t\nAS \n$$\nDECLARE\n    sql_query TEXT;  -- Stores the dynamic SQL query\nBEGIN\n    -- Construct the dynamic SQL statement\n    sql_query := format(\n        'SELECT neighborhood.name, neighborhood.geom\n        FROM %I.%I AS street\n        JOIN %I.%I AS neighborhood\n        ON ST_Intersects(street.geom, neighborhood.geom)\n        WHERE street.%I = %L', \n\t\t\n        schema_name, table_name,schema_name02,table_name02, column_name, streetName\n    );\n\n    -- Execute the dynamic query and return results\n    RETURN QUERY EXECUTE sql_query;\nEND;\n$$\nLANGUAGE plpgsql;\n\"\"\"\n\nwith engine.connect() as conn:\n    conn.execute(text(function_sql))\n    conn.commit()\n\nsql_text = \"\"\"select * from dynamic_subway_filter('ch05','streets', 'ch05', 'neighborhoods', 'name', '7th Ave')\n\"\"\"\n\noutcome_nbh = gpd.read_postgis(sql_text, con=engine)\n\n## get neighborhoods\nnbh_text = text(\"\"\" SELECT * FROM ch05.neighborhoods\"\"\")\nall_nbh = gpd.read_postgis(nbh_text, con = engine)\n\n## get outcome subway\nsubway_text = text(\"\"\" SELECT name, geom \n                      FROM ch05.streets\n                      where name = '7th Ave' \"\"\")\noutcome_street = gpd.read_postgis(subway_text, con = engine)\n\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nall_nbh.plot(ax=ax,facecolor = 'none',)\noutcome_street.plot(ax=ax, facecolor = 'none',edgecolor='red')\noutcome_nbh.plot(ax=ax, color = 'BLUE',edgecolor='black')\n\n\nplt.title('NYC Streets with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> function_sql = \"\"\" CREATE OR REPLACE FUNCTION dynamic_subway_filter(     schema_name TEXT,   -- Schema name     table_name TEXT,    -- Table name  \tschema_name02 TEXT, \ttable_name02 TEXT,  \t     column_name TEXT, -- Column name to filter     streetName TEXT -- Value to filter by ) RETURNS TABLE (     name character varying(64), \tgeom geometry(MultiPolygon,26918)) \t AS  $$ DECLARE     sql_query TEXT;  -- Stores the dynamic SQL query BEGIN     -- Construct the dynamic SQL statement     sql_query := format(         'SELECT neighborhood.name, neighborhood.geom         FROM %I.%I AS street         JOIN %I.%I AS neighborhood         ON ST_Intersects(street.geom, neighborhood.geom)         WHERE street.%I = %L',  \t\t         schema_name, table_name,schema_name02,table_name02, column_name, streetName     );      -- Execute the dynamic query and return results     RETURN QUERY EXECUTE sql_query; END; $$ LANGUAGE plpgsql; \"\"\"  with engine.connect() as conn:     conn.execute(text(function_sql))     conn.commit()  sql_text = \"\"\"select * from dynamic_subway_filter('ch05','streets', 'ch05', 'neighborhoods', 'name', '7th Ave') \"\"\"  outcome_nbh = gpd.read_postgis(sql_text, con=engine)  ## get neighborhoods nbh_text = text(\"\"\" SELECT * FROM ch05.neighborhoods\"\"\") all_nbh = gpd.read_postgis(nbh_text, con = engine)  ## get outcome subway subway_text = text(\"\"\" SELECT name, geom                        FROM ch05.streets                       where name = '7th Ave' \"\"\") outcome_street = gpd.read_postgis(subway_text, con = engine)   fig, ax = plt.subplots(figsize=(12, 10))  all_nbh.plot(ax=ax,facecolor = 'none',) outcome_street.plot(ax=ax, facecolor = 'none',edgecolor='red') outcome_nbh.plot(ax=ax, color = 'BLUE',edgecolor='black')   plt.title('NYC Streets with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True) <pre>\n---------------------------------------------------------------------------\nUndefinedTable                            Traceback (most recent call last)\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\sqlalchemy\\engine\\base.py:1964, in Connection._exec_single_context(self, dialect, context, statement, parameters)\n   1963     if not evt_handled:\n-&gt; 1964         self.dialect.do_execute(\n   1965             cursor, str_statement, effective_parameters, context\n   1966         )\n   1968 if self._has_events or self.engine._has_events:\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\sqlalchemy\\engine\\default.py:942, in DefaultDialect.do_execute(self, cursor, statement, parameters, context)\n    941 def do_execute(self, cursor, statement, parameters, context=None):\n--&gt; 942     cursor.execute(statement, parameters)\n\nUndefinedTable: relation \"ch05.streets\" does not exist\nLINE 2:         FROM ch05.streets AS street\n                     ^\nQUERY:  SELECT neighborhood.name, neighborhood.geom\n        FROM ch05.streets AS street\n        JOIN ch05.neighborhoods AS neighborhood\n        ON ST_Intersects(street.geom, neighborhood.geom)\n        WHERE street.name = '7th Ave'\nCONTEXT:  PL/pgSQL function dynamic_subway_filter(text,text,text,text,text,text) line 17 at RETURN QUERY\n\n\nThe above exception was the direct cause of the following exception:\n\nProgrammingError                          Traceback (most recent call last)\nCell In[6], line 46\n     41     conn.commit()\n     43 sql_text = \"\"\"select * from dynamic_subway_filter('ch05','streets', 'ch05', 'neighborhoods', 'name', '7th Ave')\n     44 \"\"\"\n---&gt; 46 outcome_nbh = gpd.read_postgis(sql_text, con=engine)\n     48 ## get neighborhoods\n     49 nbh_text = text(\"\"\" SELECT * FROM ch05.neighborhoods\"\"\")\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\geopandas\\io\\sql.py:185, in _read_postgis(sql, con, geom_col, crs, index_col, coerce_float, parse_dates, params, chunksize)\n    135 \"\"\"\n    136 Returns a GeoDataFrame corresponding to the result of the query\n    137 string, which must contain a geometry column in WKB representation.\n   (...)\n    180 &gt;&gt;&gt; df = geopandas.read_postgis(sql, con)  # doctest: +SKIP\n    181 \"\"\"\n    183 if chunksize is None:\n    184     # read all in one chunk and return a single GeoDataFrame\n--&gt; 185     df = pd.read_sql(\n    186         sql,\n    187         con,\n    188         index_col=index_col,\n    189         coerce_float=coerce_float,\n    190         parse_dates=parse_dates,\n    191         params=params,\n    192         chunksize=chunksize,\n    193     )\n    194     return _df_to_geodf(df, geom_col=geom_col, crs=crs, con=con)\n    196 else:\n    197     # read data in chunks and return a generator\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\pandas\\io\\sql.py:734, in read_sql(sql, con, index_col, coerce_float, params, parse_dates, columns, chunksize, dtype_backend, dtype)\n    724     return pandas_sql.read_table(\n    725         sql,\n    726         index_col=index_col,\n   (...)\n    731         dtype_backend=dtype_backend,\n    732     )\n    733 else:\n--&gt; 734     return pandas_sql.read_query(\n    735         sql,\n    736         index_col=index_col,\n    737         params=params,\n    738         coerce_float=coerce_float,\n    739         parse_dates=parse_dates,\n    740         chunksize=chunksize,\n    741         dtype_backend=dtype_backend,\n    742         dtype=dtype,\n    743     )\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\pandas\\io\\sql.py:1836, in SQLDatabase.read_query(self, sql, index_col, coerce_float, parse_dates, params, chunksize, dtype, dtype_backend)\n   1779 def read_query(\n   1780     self,\n   1781     sql: str,\n   (...)\n   1788     dtype_backend: DtypeBackend | Literal[\"numpy\"] = \"numpy\",\n   1789 ) -&gt; DataFrame | Iterator[DataFrame]:\n   1790     \"\"\"\n   1791     Read SQL query into a DataFrame.\n   1792 \n   (...)\n   1834 \n   1835     \"\"\"\n-&gt; 1836     result = self.execute(sql, params)\n   1837     columns = result.keys()\n   1839     if chunksize is not None:\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\pandas\\io\\sql.py:1659, in SQLDatabase.execute(self, sql, params)\n   1657 args = [] if params is None else [params]\n   1658 if isinstance(sql, str):\n-&gt; 1659     return self.con.exec_driver_sql(sql, *args)\n   1660 return self.con.execute(sql, *args)\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\sqlalchemy\\engine\\base.py:1776, in Connection.exec_driver_sql(self, statement, parameters, execution_options)\n   1771 execution_options = self._execution_options.merge_with(\n   1772     execution_options\n   1773 )\n   1775 dialect = self.dialect\n-&gt; 1776 ret = self._execute_context(\n   1777     dialect,\n   1778     dialect.execution_ctx_cls._init_statement,\n   1779     statement,\n   1780     None,\n   1781     execution_options,\n   1782     statement,\n   1783     distilled_parameters,\n   1784 )\n   1786 return ret\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\sqlalchemy\\engine\\base.py:1843, in Connection._execute_context(self, dialect, constructor, statement, parameters, execution_options, *args, **kw)\n   1841     return self._exec_insertmany_context(dialect, context)\n   1842 else:\n-&gt; 1843     return self._exec_single_context(\n   1844         dialect, context, statement, parameters\n   1845     )\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\sqlalchemy\\engine\\base.py:1983, in Connection._exec_single_context(self, dialect, context, statement, parameters)\n   1980     result = context._setup_result_proxy()\n   1982 except BaseException as e:\n-&gt; 1983     self._handle_dbapi_exception(\n   1984         e, str_statement, effective_parameters, cursor, context\n   1985     )\n   1987 return result\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2352, in Connection._handle_dbapi_exception(self, e, statement, parameters, cursor, context, is_sub_exec)\n   2350 elif should_wrap:\n   2351     assert sqlalchemy_exception is not None\n-&gt; 2352     raise sqlalchemy_exception.with_traceback(exc_info[2]) from e\n   2353 else:\n   2354     assert exc_info[1] is not None\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\sqlalchemy\\engine\\base.py:1964, in Connection._exec_single_context(self, dialect, context, statement, parameters)\n   1962                 break\n   1963     if not evt_handled:\n-&gt; 1964         self.dialect.do_execute(\n   1965             cursor, str_statement, effective_parameters, context\n   1966         )\n   1968 if self._has_events or self.engine._has_events:\n   1969     self.dispatch.after_cursor_execute(\n   1970         self,\n   1971         cursor,\n   (...)\n   1975         context.executemany,\n   1976     )\n\nFile d:\\Anaconda\\envs\\sql\\lib\\site-packages\\sqlalchemy\\engine\\default.py:942, in DefaultDialect.do_execute(self, cursor, statement, parameters, context)\n    941 def do_execute(self, cursor, statement, parameters, context=None):\n--&gt; 942     cursor.execute(statement, parameters)\n\nProgrammingError: (psycopg2.errors.UndefinedTable) relation \"ch05.streets\" does not exist\nLINE 2:         FROM ch05.streets AS street\n                     ^\nQUERY:  SELECT neighborhood.name, neighborhood.geom\n        FROM ch05.streets AS street\n        JOIN ch05.neighborhoods AS neighborhood\n        ON ST_Intersects(street.geom, neighborhood.geom)\n        WHERE street.name = '7th Ave'\nCONTEXT:  PL/pgSQL function dynamic_subway_filter(text,text,text,text,text,text) line 17 at RETURN QUERY\n\n[SQL: select * from dynamic_subway_filter('ch05','streets', 'ch05', 'neighborhoods', 'name', '7th Ave')\n]\n(Background on this error at: https://sqlalche.me/e/20/f405)</pre> In\u00a0[\u00a0]: Copied! <pre>outcome_street\n</pre> outcome_street Out[\u00a0]: name geom 0 8th Ave MULTILINESTRING ((586868.896 4505728.274, 5868... 1 8th Ave MULTILINESTRING ((587881.695 4517139.039, 5879... 2 8th Ave MULTILINESTRING ((591470.025 4490336.594, 5914... 3 8th Ave MULTILINESTRING ((596967.23 4516070.677, 59707... 4 8th Ave MULTILINESTRING ((597125.349 4516097.855, 5972... 5 8th Ave MULTILINESTRING ((599180.275 4516326.301, 5992... 6 8th Ave MULTILINESTRING ((599290.59 4516362.089, 59946... 7 8th Ave MULTILINESTRING ((568445.16 4497212.582, 56840... 8 8th Ave MULTILINESTRING ((584800.309 4500115.151, 5847... 9 8th Ave MULTILINESTRING ((583967.994 4510028.476, 5840... 10 8th Ave MULTILINESTRING ((585699.738 4501278.185, 5857..."},{"location":"Lectures/Week01/Week01_Intro/","title":"Week 1 Lecture","text":""},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/","title":"Instructor spatialRelationship Part02","text":"In\u00a0[50]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[51]: Copied! <pre>host = 'localhost'\ndatabase = 'spatialdata'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatialdata' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') In\u00a0[52]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\" In\u00a0[53]: Copied! <pre>engine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() Out[53]: <pre>['spatial_ref_sys', 'nyc_census_blocks_2000', 'nyc_subway_stations']</pre> In\u00a0[54]: Copied! <pre>nei_intersect = text(\"\"\"SELECT street.name, subway.borough, street.geom\nFROM ch05.streets AS street, ch05.subway AS subway\nWHERE ST_Intersects(street.geom, ST_Buffer(subway.geom, 50));\n\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nall_sub = text(\"\"\" SELECT * FROM ch05.subway\"\"\")\nall_subway = gpd.read_postgis(all_sub, con = engine)\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nsub_neighborhoods.plot(ax=ax)\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\n\n\nplt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> nei_intersect = text(\"\"\"SELECT street.name, subway.borough, street.geom FROM ch05.streets AS street, ch05.subway AS subway WHERE ST_Intersects(street.geom, ST_Buffer(subway.geom, 50)); \"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  all_sub = text(\"\"\" SELECT * FROM ch05.subway\"\"\") all_subway = gpd.read_postgis(all_sub, con = engine)  fig, ax = plt.subplots(figsize=(12, 10))  sub_neighborhoods.plot(ax=ax) all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')   plt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\2354028167.py:18: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> In\u00a0[55]: Copied! <pre>nei_intersect = text(\"\"\"SELECT street.name, street.geom\nFROM ch05.streets AS street, ch05.subway AS subway\nWHERE street.oneway = 'yes' AND ST_Intersects(street.geom, ST_Buffer(subway.geom, 50))\n\n\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nall_sub = text(\"\"\" SELECT * FROM ch05.subway\"\"\")\nall_subway = gpd.read_postgis(all_sub, con = engine)\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nsub_neighborhoods.plot(ax=ax)\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\n\n\nplt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> nei_intersect = text(\"\"\"SELECT street.name, street.geom FROM ch05.streets AS street, ch05.subway AS subway WHERE street.oneway = 'yes' AND ST_Intersects(street.geom, ST_Buffer(subway.geom, 50))  \"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  all_sub = text(\"\"\" SELECT * FROM ch05.subway\"\"\") all_subway = gpd.read_postgis(all_sub, con = engine)  fig, ax = plt.subplots(figsize=(12, 10))  sub_neighborhoods.plot(ax=ax) all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')   plt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\1355374284.py:19: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> In\u00a0[56]: Copied! <pre>nei_intersect = text(\"\"\"SELECT nbh.boroname, COUNT(*) AS station_count, nbh.geom\nFROM ch05.neighborhoods AS nbh, ch05.subway as subway\nWHERE ST_Intersects(nbh.geom, subway.geom)\nGROUP BY nbh.boroname, nbh.geom;\n\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nsub_neighborhoods.plot()\n\nsub_neighborhoods.head()\n</pre>  nei_intersect = text(\"\"\"SELECT nbh.boroname, COUNT(*) AS station_count, nbh.geom FROM ch05.neighborhoods AS nbh, ch05.subway as subway WHERE ST_Intersects(nbh.geom, subway.geom) GROUP BY nbh.boroname, nbh.geom; \"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  sub_neighborhoods.plot()  sub_neighborhoods.head() Out[56]: boroname station_count geom 0 Brooklyn 5 MULTIPOLYGON (((581448.518 4499392.214, 583061... 1 Brooklyn 4 MULTIPOLYGON (((581037.025 4497503.442, 581046... 2 Brooklyn 3 MULTIPOLYGON (((585179.531 4504772.245, 585620... 3 Brooklyn 9 MULTIPOLYGON (((585179.531 4504772.245, 585005... 4 Brooklyn 10 MULTIPOLYGON (((583702.47 4498276.23, 584297.4... In\u00a0[57]: Copied! <pre>nei_intersect = text(\"\"\"SELECT nbh.boroname, COUNT(*) AS station_count, nbh.geom\nFROM ch05.neighborhoods AS nbh, ch05.subway as subway\nWHERE ST_Intersects(nbh.geom, subway.geom)\nGROUP BY boroname, nbh.geom\nHAVING COUNT(*) &gt; 10;\n\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nsub_neighborhoods.plot()\n</pre> nei_intersect = text(\"\"\"SELECT nbh.boroname, COUNT(*) AS station_count, nbh.geom FROM ch05.neighborhoods AS nbh, ch05.subway as subway WHERE ST_Intersects(nbh.geom, subway.geom) GROUP BY boroname, nbh.geom HAVING COUNT(*) &gt; 10; \"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  sub_neighborhoods.plot()  Out[57]: <pre>&lt;Axes: &gt;</pre> In\u00a0[58]: Copied! <pre>nei_intersect = text(\"\"\"SELECT subway.name, street.name, subway.geom\nFROM ch05.subway AS subway, ch05.streets AS street\nWHERE subway.express = 'express' AND street.type = 'residential'AND ST_Intersects(ST_Buffer(subway.geom, 50), street.geom);\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nsub_neighborhoods.plot()\n</pre> nei_intersect = text(\"\"\"SELECT subway.name, street.name, subway.geom FROM ch05.subway AS subway, ch05.streets AS street WHERE subway.express = 'express' AND street.type = 'residential'AND ST_Intersects(ST_Buffer(subway.geom, 50), street.geom);\"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  sub_neighborhoods.plot() Out[58]: <pre>&lt;Axes: &gt;</pre> In\u00a0[59]: Copied! <pre>streets = text(\"\"\"SELECT nbh.boroname, nbh.geom\nFROM ch05.neighborhoods AS nbh, ch05.subway  \nWHERE ST_Disjoint(nbh.geom, ch05.subway.geom);\n\"\"\")\n\nsub_streets = gpd.read_postgis(streets, con=engine)\n\nall_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nsub_streets.plot(ax=ax)\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\n\n\nplt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> streets = text(\"\"\"SELECT nbh.boroname, nbh.geom FROM ch05.neighborhoods AS nbh, ch05.subway   WHERE ST_Disjoint(nbh.geom, ch05.subway.geom); \"\"\")  sub_streets = gpd.read_postgis(streets, con=engine)  all_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")  fig, ax = plt.subplots(figsize=(12, 10))  sub_streets.plot(ax=ax) all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')   plt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\3173271475.py:17: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> In\u00a0[66]: Copied! <pre>streets = text(\"\"\"SELECT nbh.boroname, nbh.geom\nFROM ch05.neighborhoods AS nbh\nWHERE NOT EXISTS (\n    SELECT *\n    FROM ch05.subway AS subway\n    WHERE ST_Disjoint(nbh.geom, subway.geom) = FALSE);\"\"\")\n\n\nsub_streets = gpd.read_postgis(streets, con=engine)\n\nall_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nsub_streets.plot(ax=ax)\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\n\n\nplt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> streets = text(\"\"\"SELECT nbh.boroname, nbh.geom FROM ch05.neighborhoods AS nbh WHERE NOT EXISTS (     SELECT *     FROM ch05.subway AS subway     WHERE ST_Disjoint(nbh.geom, subway.geom) = FALSE);\"\"\")   sub_streets = gpd.read_postgis(streets, con=engine)  all_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")  fig, ax = plt.subplots(figsize=(12, 10))  sub_streets.plot(ax=ax) all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')   plt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\3430380508.py:20: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> In\u00a0[61]: Copied! <pre>streets = text(\"\"\"SELECT street.name, street.geom\nFROM ch05.streets AS street\nWHERE NOT EXISTS (\n    SELECT * \n    FROM ch05.subway    \n    WHERE ST_Intersects(street.geom, ST_Buffer(ch05.subway.geom, 500)))\"\"\")\n\nsub_streets = gpd.read_postgis(streets, con=engine)\n\nall_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\nsub_streets.plot(ax=ax)\n\nplt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> streets = text(\"\"\"SELECT street.name, street.geom FROM ch05.streets AS street WHERE NOT EXISTS (     SELECT *      FROM ch05.subway         WHERE ST_Intersects(street.geom, ST_Buffer(ch05.subway.geom, 500)))\"\"\")  sub_streets = gpd.read_postgis(streets, con=engine)  all_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")  fig, ax = plt.subplots(figsize=(12, 10))  all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black') sub_streets.plot(ax=ax)  plt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\3874947142.py:18: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> In\u00a0[62]: Copied! <pre>streets = text(\"\"\"SELECT street.name, street.geom\nFROM ch05.streets AS street\nWHERE NOT EXISTS (\n    SELECT *\n    FROM ch05.subway    \n    WHERE ST_DWithin(street.geom, ch05.subway.geom, 500));\n    \"\"\")\n\nsub_streets = gpd.read_postgis(streets, con=engine)\n\nall_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\nsub_streets.plot(ax=ax)\n\nplt.title('NYC Neighborhoods not within 500m buffer of subway stations', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> streets = text(\"\"\"SELECT street.name, street.geom FROM ch05.streets AS street WHERE NOT EXISTS (     SELECT *     FROM ch05.subway         WHERE ST_DWithin(street.geom, ch05.subway.geom, 500));     \"\"\")  sub_streets = gpd.read_postgis(streets, con=engine)  all_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")  fig, ax = plt.subplots(figsize=(12, 10))  all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black') sub_streets.plot(ax=ax)  plt.title('NYC Neighborhoods not within 500m buffer of subway stations', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\2895450043.py:19: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#ST_Intersects","title":"ST_Intersects\u00b6","text":"<p>ST_Intersects(geometry A, geometry B)</p> <p></p>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#Example-1:-ST_Intersects","title":"Example 1: ST_Intersects\u00b6","text":"<p>Find all streets within 50 meters of subway stations (using buffer).</p> <p>ST_Intersects( geometry geomA , geometry geomB )</p>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#Exercise-01-ST_Intersects","title":"Exercise 01 ST_Intersects\u00b6","text":"<p>Find all one-way streets within 50 meters of subway stations.</p> <p>column [oneway] in street  = 'yes'</p>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#Example-02:-ST_Intersects","title":"Example 02: ST_Intersects\u00b6","text":"<p>Identify neighborhoods where there are subway stations, count the total count of subway in each neighborhoods</p> <ul> <li>Combination between WHERE AND GROUP BY</li> </ul>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#Exercise-02:-ST_Intersects","title":"Exercise 02: ST_Intersects\u00b6","text":"<ol> <li>Identify neighborhoods with more than 10 subway stations using HAVING COUNT(*)</li> </ol>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#Example-03:-ST_Intersects","title":"Example 03: ST_Intersects\u00b6","text":"<p>List all subway stations where express trains stop that are within 50 meters of residential roads.</p> <p>column[express] in subway = 'express' column[type] in sbuway = 'residential'</p>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#ST_Disjoint","title":"ST_Disjoint\u00b6","text":"<p>The opposite of ST_Intersects is ST_Disjoint(geometry A , geometry B).</p> <p></p>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#Example-01:-ST_Disjoint","title":"Example 01: ST_Disjoint\u00b6","text":"<p>List neighborhoods Disjoint with 500 meters buffer of subway stations.</p> <p>Directly using ST_Disjoint(), do you find any problem with the results?</p>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#Exercise-01:-ST_Disjoint---Subquery-with-NOT-EXISTS","title":"Exercise 01: ST_Disjoint - Subquery with NOT EXISTS\u00b6","text":"<p>List neighborhoods Disjoint with 500 meters buffer of subway stations.</p> <ul> <li>Remove neighborhoods that intersect (Not Disjoint) with subway</li> </ul>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#Exercise-02:-ST_Intersect-and-ST_Buffer","title":"Exercise 02: ST_Intersect and ST_Buffer\u00b6","text":"<p>SQL is flexible, using ST_Intersects and ST_Buffer to acheieve the same goal from Exercise 01: ST_Disjoint - Subquery with NOT EXISTS</p>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#ST_DWithin","title":"ST_DWithin\u00b6","text":"<p>ST_DWithin(geometry g1, geometry g2, double precision distance_of_srid)</p> <p></p>"},{"location":"Lectures/Week05/Instructor_spatialRelationship_Part02/#Example-1:-ST_DWithin","title":"Example 1: ST_DWithin\u00b6","text":"<p>List street segments that have distance over than 500 meters to subway staiton</p>"},{"location":"Lectures/Week05/Instructor_spatial_relationship/","title":"Instructor spatial relationship","text":"In\u00a0[18]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[4]: Copied! <pre>host = 'localhost'\ndatabase = 'spatialdata'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatialdata' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') <p>Check your passworkd</p> <p>print(os.getenv('SQL_PASSWORD'))</p> In\u00a0[5]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\" In\u00a0[6]: Copied! <pre>engine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() Out[6]: <pre>['spatial_ref_sys', 'nyc_census_blocks_2000', 'nyc_subway_stations']</pre> In\u00a0[28]: Copied! <pre>streets = text(\"SELECT * FROM  ch05.nyc_neighborhoods LIMIT 10\")\n\nsub_streetsub_street = gpd.read_postgis(streets, con=engine)\n</pre> streets = text(\"SELECT * FROM  ch05.nyc_neighborhoods LIMIT 10\")  sub_streetsub_street = gpd.read_postgis(streets, con=engine) In\u00a0[30]: Copied! <pre>sub_streetsub_street.plot()\n</pre> sub_streetsub_street.plot() Out[30]: <pre>&lt;Axes: &gt;</pre> In\u00a0[44]: Copied! <pre>query = text(\"SELECT * FROM ch05.nyc_neighborhoods\")\nneighborhood_shp = gpd.read_postgis(query, con=engine)\nneighborhood_shp.plot()\n</pre> query = text(\"SELECT * FROM ch05.nyc_neighborhoods\") neighborhood_shp = gpd.read_postgis(query, con=engine) neighborhood_shp.plot() Out[44]: <pre>&lt;Axes: &gt;</pre> In\u00a0[48]: Copied! <pre># Write and execute your SQL query\nquery = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom\nFROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways  \nWHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname = 'Manhattan'\n                \"\"\")\n\nall_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")\n\nsub_subway = gpd.read_postgis(query, con=engine)\n\nsub_subway.plot()\n</pre> # Write and execute your SQL query query = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom FROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways   WHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname = 'Manhattan'                 \"\"\")  all_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")  sub_subway = gpd.read_postgis(query, con=engine)  sub_subway.plot()  Out[48]: <pre>&lt;Axes: &gt;</pre> In\u00a0[49]: Copied! <pre>fig, ax = plt.subplots(figsize=(12, 10))\n\nneighborhood_shp.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')\n\n# Plot subway stations in red\nsub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')\n\n# Add title, legend, and grid\nplt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(12, 10))  neighborhood_shp.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')  # Plot subway stations in red sub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')  # Add title, legend, and grid plt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True)  # Show the plot plt.show() <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_25816\\3855605619.py:10: UserWarning: Legend does not support handles for PatchCollection instances.\nSee: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler\n  plt.legend()\n</pre> In\u00a0[51]: Copied! <pre>query = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom\nFROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways  \nWHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname IN ('Queens', 'Brooklyn')\n                \"\"\")\n\nsubway_intwo = gpd.read_postgis(query, con=engine)\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nneighborhood_shp.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')\n\n# Plot subway stations in red\nsubway_intwo.plot(ax=ax, color='red', markersize=50, label='Subway Stations')\n\n# Add title, legend, and grid\nplt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n</pre> query = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom FROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways   WHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname IN ('Queens', 'Brooklyn')                 \"\"\")  subway_intwo = gpd.read_postgis(query, con=engine)  fig, ax = plt.subplots(figsize=(12, 10))  neighborhood_shp.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')  # Plot subway stations in red subway_intwo.plot(ax=ax, color='red', markersize=50, label='Subway Stations')  # Add title, legend, and grid plt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True)  # Show the plot plt.show() <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_25816\\956140008.py:17: UserWarning: Legend does not support handles for PatchCollection instances.\nSee: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler\n  plt.legend()\n</pre>"},{"location":"Lectures/Week05/Instructor_spatial_relationship/#Add-the-passworkd-to-User-Variabels-for-Administrator","title":"Add the passworkd to User Variabels for Administrator\u00b6","text":"<ul> <li>System Properties</li> <li>Envrionment Variables</li> <li>New</li> <li>Variable name: SQL_PASSWORD ; Variable value: the password for postgresql</li> </ul>"},{"location":"Lectures/Week05/Instructor_spatial_relationship/#Select-Ten-Features-FROM-nyc_neighborhoods","title":"Select Ten Features FROM nyc_neighborhoods\u00b6","text":""},{"location":"Lectures/Week05/Instructor_spatial_relationship/#Select-All-features-from-nyc_neighborhoods","title":"Select All features from nyc_neighborhoods\u00b6","text":""},{"location":"Lectures/Week05/Instructor_spatial_relationship/#ST_Instersects","title":"ST_Instersects\u00b6","text":"<p>Identify all subway stations that intersect with neighborhoods = 'Manhattan'</p>"},{"location":"Lectures/Week05/Instructor_spatial_relationship/#Plot-neighborhoods-and-Manhattan","title":"Plot neighborhoods and Manhattan\u00b6","text":""},{"location":"Lectures/Week05/Instructor_spatial_relationship/#Exercise-1:-Select-subway-stations-that-locate-in-neighborhoods-in-'Queens',-'Brooklyn'","title":"Exercise 1: Select subway stations that locate in neighborhoods in 'Queens', 'Brooklyn'\u00b6","text":""},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/","title":"Week 5 Lecture Part 02","text":"In\u00a0[3]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[4]: Copied! <pre>host = 'localhost'\ndatabase = 'spatialdata'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatialdata' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') In\u00a0[5]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\" In\u00a0[6]: Copied! <pre>engine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() Out[6]: <pre>['spatial_ref_sys', 'nyc_census_blocks_2000', 'nyc_subway_stations']</pre> <p>SELECT street.name, subway.borough, street.geom</p> <p>FROM ch05.streets AS street, ch05.subway AS subway</p> <p>WHERE _________</p> In\u00a0[\u00a0]: Copied! <pre>nei_intersect = text(\"\"\"\n\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nall_sub = text(\"\"\" SELECT * FROM ch05.subway\"\"\")\nall_subway = gpd.read_postgis(all_sub, con = engine)\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nsub_neighborhoods.plot(ax=ax)\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\n\n\nplt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> nei_intersect = text(\"\"\" \"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  all_sub = text(\"\"\" SELECT * FROM ch05.subway\"\"\") all_subway = gpd.read_postgis(all_sub, con = engine)  fig, ax = plt.subplots(figsize=(12, 10))  sub_neighborhoods.plot(ax=ax) all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')   plt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\2354028167.py:18: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> <p>SELECT street.name, street.geom</p> <p>FROM ch05.streets AS street, ch05.subway AS subway</p> <p>WHERE _____________________________</p> In\u00a0[\u00a0]: Copied! <pre>nei_intersect = text(\"\"\"\n\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nall_sub = text(\"\"\" SELECT * FROM ch05.subway\"\"\")\nall_subway = gpd.read_postgis(all_sub, con = engine)\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nsub_neighborhoods.plot(ax=ax)\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\n\n\nplt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> nei_intersect = text(\"\"\" \"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  all_sub = text(\"\"\" SELECT * FROM ch05.subway\"\"\") all_subway = gpd.read_postgis(all_sub, con = engine)  fig, ax = plt.subplots(figsize=(12, 10))  sub_neighborhoods.plot(ax=ax) all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')   plt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\1355374284.py:19: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> <p>SELECT nbh.boroname, COUNT(*) AS station_count, nbh.geom</p> <p>FROM ch05.neighborhoods AS nbh, ch05.subway as subway</p> <p>WHERE _______________________________</p> <p>GROUP BY ______________________</p> In\u00a0[\u00a0]: Copied! <pre>nei_intersect = text(\"\"\"\n\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nsub_neighborhoods.plot()\n\nsub_neighborhoods.head()\n</pre> nei_intersect = text(\"\"\" \"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  sub_neighborhoods.plot()  sub_neighborhoods.head() Out[\u00a0]: boroname station_count geom 0 Brooklyn 5 MULTIPOLYGON (((581448.518 4499392.214, 583061... 1 Brooklyn 4 MULTIPOLYGON (((581037.025 4497503.442, 581046... 2 Brooklyn 3 MULTIPOLYGON (((585179.531 4504772.245, 585620... 3 Brooklyn 9 MULTIPOLYGON (((585179.531 4504772.245, 585005... 4 Brooklyn 10 MULTIPOLYGON (((583702.47 4498276.23, 584297.4... <p>SELECT nbh.boroname, COUNT(*) AS station_count, nbh.geom</p> <p>FROM ch05.neighborhoods AS nbh, ch05.subway as subway</p> <p>WHERE \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014</p> <p>GROUP BY \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014</p> <p>HAVING \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014;</p> In\u00a0[\u00a0]: Copied! <pre>nei_intersect = text(\"\"\"\n\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nsub_neighborhoods.plot()\n</pre> nei_intersect = text(\"\"\" \"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  sub_neighborhoods.plot()  Out[\u00a0]: <pre>&lt;Axes: &gt;</pre> <p>SELECT subway.name, street.name, subway.geom</p> <p>FROM ch05.subway AS subway, ch05.streets AS street</p> <p>WHERE \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 AND \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 AND \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014;</p> In\u00a0[\u00a0]: Copied! <pre>nei_intersect = text(\"\"\"\"\"\")\n\nsub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)\n\nsub_neighborhoods.plot()\n</pre> nei_intersect = text(\"\"\"\"\"\")  sub_neighborhoods = gpd.read_postgis(nei_intersect, con=engine)  sub_neighborhoods.plot() Out[\u00a0]: <pre>&lt;Axes: &gt;</pre> <p>SELECT nbh.boroname, nbh.geom</p> <p>FROM ch05.neighborhoods AS nbh, ch05.subway</p> <p>WHERE \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014;</p> In\u00a0[\u00a0]: Copied! <pre>streets = text(\"\"\"\n\"\"\")\n\nsub_streets = gpd.read_postgis(streets, con=engine)\n\nall_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nsub_streets.plot(ax=ax)\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\n\n\nplt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> streets = text(\"\"\" \"\"\")  sub_streets = gpd.read_postgis(streets, con=engine)  all_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")  fig, ax = plt.subplots(figsize=(12, 10))  sub_streets.plot(ax=ax) all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')   plt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\3173271475.py:17: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> <p>SELECT nbh.boroname, nbh.geom</p> <p>FROM ch05.neighborhoods AS nbh</p> <p>WHERE NOT EXISTS (\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014);</p> In\u00a0[\u00a0]: Copied! <pre>streets = text(\"\"\"\"\"\")\n\nsub_streets = gpd.read_postgis(streets, con=engine)\n\nall_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\nsub_streets.plot(ax=ax)\n\nplt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> streets = text(\"\"\"\"\"\")  sub_streets = gpd.read_postgis(streets, con=engine)  all_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")  fig, ax = plt.subplots(figsize=(12, 10))  all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black') sub_streets.plot(ax=ax)  plt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\3639610047.py:18: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> <p>SELECT street.name, street.geom</p> <p>FROM ch05.streets AS street</p> <p>WHERE NOT EXISTS (\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014)</p> In\u00a0[\u00a0]: Copied! <pre>streets = text(\"\"\"\"\"\")\n\nsub_streets = gpd.read_postgis(streets, con=engine)\n\nall_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\nsub_streets.plot(ax=ax)\n\nplt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> streets = text(\"\"\"\"\"\")  sub_streets = gpd.read_postgis(streets, con=engine)  all_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")  fig, ax = plt.subplots(figsize=(12, 10))  all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black') sub_streets.plot(ax=ax)  plt.title('NYC Neighborhoods Disjoint with 500m buffer of subway stations', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_44280\\2351892699.py:22: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre> <p>SELECT street.name, street.geom</p> <p>FROM ch05.streets AS street</p> <p>WHERE NOT EXISTS (\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014);</p> In\u00a0[\u00a0]: Copied! <pre>streets = text(\"\"\"\n    \"\"\")\n\nsub_streets = gpd.read_postgis(streets, con=engine)\n\nall_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nall_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\nsub_streets.plot(ax=ax)\n\nplt.title('NYC Neighborhoods not within 500m buffer of subway stations', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> streets = text(\"\"\"     \"\"\")  sub_streets = gpd.read_postgis(streets, con=engine)  all_sub = text(\"\"\"SELECT * FROM ch05.subway\"\"\")  fig, ax = plt.subplots(figsize=(12, 10))  all_subway.plot(ax=ax, facecolor = 'none',edgecolor='black') sub_streets.plot(ax=ax)  plt.title('NYC Neighborhoods not within 500m buffer of subway stations', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_6904\\512485809.py:19: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#ST_Intersects","title":"ST_Intersects\u00b6","text":"<p>ST_Intersects(geometry A, geometry B)</p> <p></p>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#Example-1:-ST_Intersects","title":"Example 1: ST_Intersects\u00b6","text":"<p>Find all streets within 50 meters of subway stations (using buffer).</p> <p>ST_Intersects( geometry geomA , ST_Buffer(geometry geomB, distance))</p> <p>ST_Buffer</p>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#Exercise-01-ST_Intersects","title":"Exercise 01 ST_Intersects\u00b6","text":"<p>Find all one-way streets within 50 meters of subway stations.</p> <p>column [oneway] in street  = 'yes'</p>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#Example-02:-ST_Intersects","title":"Example 02: ST_Intersects\u00b6","text":"<p>Identify neighborhoods where there are subway stations, count the total count of subway in each neighborhoods</p> <ul> <li>Combination between WHERE AND GROUP BY</li> </ul>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#Exercise-02:-ST_Intersects","title":"Exercise 02: ST_Intersects\u00b6","text":"<ol> <li>Identify neighborhoods with more than 10 subway stations using HAVING COUNT(*)</li> </ol>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#Example-03:-ST_Intersects","title":"Example 03: ST_Intersects\u00b6","text":"<p>List all subway stations where express trains stop that are within 50 meters of residential roads.</p> <p>column[express] in subway = 'express' column[type] in sbuway = 'residential'</p>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#ST_Disjoint","title":"ST_Disjoint\u00b6","text":"<p>The opposite of ST_Intersects is ST_Disjoint(geometry A , geometry B).</p> <p></p>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#Example-01:-ST_Disjoint","title":"Example 01: ST_Disjoint\u00b6","text":"<p>List neighborhoods Disjoint with 500 meters buffer of subway stations.</p> <p>Directly using ST_Disjoint(), do you find any problem with the results?</p>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#Exercise-01:-ST_Disjoint---Subquery-with-NOT-EXISTS","title":"Exercise 01: ST_Disjoint - Subquery with NOT EXISTS\u00b6","text":"<p>List neighborhoods Disjoint with 500 meters buffer of subway stations.</p> <ul> <li>Remove neighborhoods that intersect (Not Disjoint) with subway</li> </ul>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#Exercise-02:-ST_Intersect-and-ST_Buffer","title":"Exercise 02: ST_Intersect and ST_Buffer\u00b6","text":"<p>List street segments that outside of 500m buffer of subway station</p>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#ST_DWithin","title":"ST_DWithin\u00b6","text":"<p>ST_DWithin(geometry g1, geometry g2, double precision distance_of_srid)</p> <p></p>"},{"location":"Lectures/Week05/Student_spatialRelationship_Part02/#Example-1:-ST_DWithin","title":"Example 1: ST_DWithin\u00b6","text":"<p>List street segments that have distance over than 500 meters to subway staiton</p>"},{"location":"Lectures/Week05/Student_spatial_relationship/","title":"Week 5 Lecture","text":"Week 5: Spatial Relationship      In\u00a0[3]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[4]: Copied! <pre>host = 'localhost'\ndatabase = 'spatial'\nuser = os.getenv('SQL_USER')\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatial' user = os.getenv('SQL_USER') port = '5432' password = os.getenv('SQL_PASSWORD') <p>Check your passworkd</p> <p>print(os.getenv('SQL_PASSWORD'))</p> In\u00a0[5]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\" In\u00a0[6]: Copied! <pre>engine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() Out[6]: <pre>['spatial_ref_sys', 'us_tract_2020']</pre> In\u00a0[7]: Copied! <pre>streets = text(\"SELECT * FROM  ch05.nyc_neighborhoods LIMIT 10\")\n\nsub_streetsub_street = gpd.read_postgis(streets, con=engine)\n</pre> streets = text(\"SELECT * FROM  ch05.nyc_neighborhoods LIMIT 10\")  sub_streetsub_street = gpd.read_postgis(streets, con=engine) In\u00a0[8]: Copied! <pre>sub_streetsub_street\n</pre> sub_streetsub_street Out[8]: gid boroname name geom 0 1 Brooklyn Bensonhurst MULTIPOLYGON (((582771.426 4495167.427, 584651... 1 2 Manhattan East Village MULTIPOLYGON (((585508.753 4509691.267, 586826... 2 3 Manhattan West Village MULTIPOLYGON (((583263.278 4509242.626, 583276... 3 4 The Bronx Throggs Neck MULTIPOLYGON (((597640.009 4520272.72, 597647.... 4 5 The Bronx Wakefield-Williamsbridge MULTIPOLYGON (((595285.205 4525938.798, 595348... 5 6 Queens Auburndale MULTIPOLYGON (((600973.009 4510338.857, 601002... 6 7 Manhattan Battery Park MULTIPOLYGON (((583408.101 4508093.111, 583356... 7 8 Manhattan Carnegie Hill MULTIPOLYGON (((588501.208 4515525.88, 588125.... 8 9 Staten Island Mariners Harbor MULTIPOLYGON (((570300.108 4497031.156, 570393... 9 10 Staten Island Rossville MULTIPOLYGON (((564664.957 4489358.427, 564771... In\u00a0[9]: Copied! <pre>sub_streetsub_street.plot()\n</pre> sub_streetsub_street.plot() Out[9]: <pre>&lt;Axes: &gt;</pre> In\u00a0[10]: Copied! <pre>query = text(\"SELECT * FROM ch05.nyc_neighborhoods\")\nneighborhood_shp = gpd.read_postgis(query, con=engine)\nneighborhood_shp.plot()\n</pre> query = text(\"SELECT * FROM ch05.nyc_neighborhoods\") neighborhood_shp = gpd.read_postgis(query, con=engine) neighborhood_shp.plot() Out[10]: <pre>&lt;Axes: &gt;</pre> In\u00a0[11]: Copied! <pre># Write and execute your SQL query\nquery = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom\nFROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways  \nWHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname = 'Manhattan'\n                \"\"\")\n\nall_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")\n\nsub_subway = gpd.read_postgis(query, con=engine)\n\nsub_subway.plot()\n</pre> # Write and execute your SQL query query = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom FROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways   WHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname = 'Manhattan'                 \"\"\")  all_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")  sub_subway = gpd.read_postgis(query, con=engine)  sub_subway.plot()  Out[11]: <pre>&lt;Axes: &gt;</pre> In\u00a0[12]: Copied! <pre>fig, ax = plt.subplots(figsize=(12, 10))\n\nneighborhood_shp.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')\n\n# Plot subway stations in red\nsub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')\n\n# Add title, legend, and grid\nplt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(12, 10))  neighborhood_shp.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')  # Plot subway stations in red sub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')  # Add title, legend, and grid plt.title('NYC Neighborhoods with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True)  # Show the plot plt.show() <pre>C:\\Users\\yyang\\AppData\\Local\\Temp\\ipykernel_19008\\3855605619.py:10: UserWarning: Legend does not support handles for PatchCollection instances.\nSee: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler\n  plt.legend()\n</pre> In\u00a0[16]: Copied! <pre># Write and execute your SQL query\nquery = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom\nFROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways  \nWHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname = 'Queens' OR \n              ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname = 'Brooklyn'\n                \"\"\")\n\nall_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")\n\nsub_subway = gpd.read_postgis(query, con=engine)\n\nall_neighbors = gpd.read_postgis(all_nbg, con = engine)\n\n## Plot maps\n\nig, ax = plt.subplots(figsize=(12, 10))\n\nall_neighbors.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')\n\n# Plot subway stations in red\nsub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')\n\n# Add title, legend, and grid\nplt.title('NYC Neighborhoods with Subway Stations in Queens, Brooklyn', fontsize=15)\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n</pre> # Write and execute your SQL query query = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom FROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways   WHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname = 'Queens' OR                ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname = 'Brooklyn'                 \"\"\")  all_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")  sub_subway = gpd.read_postgis(query, con=engine)  all_neighbors = gpd.read_postgis(all_nbg, con = engine)  ## Plot maps  ig, ax = plt.subplots(figsize=(12, 10))  all_neighbors.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')  # Plot subway stations in red sub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')  # Add title, legend, and grid plt.title('NYC Neighborhoods with Subway Stations in Queens, Brooklyn', fontsize=15) plt.legend() plt.grid(True)  # Show the plot plt.show()   <pre>C:\\Users\\yyang\\AppData\\Local\\Temp\\ipykernel_19008\\2627626303.py:25: UserWarning: Legend does not support handles for PatchCollection instances.\nSee: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler\n  plt.legend()\n</pre> In\u00a0[17]: Copied! <pre># Write and execute your SQL query\nquery = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom\nFROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways  \nWHERE ST_Intersects(nbh.geom, subways.geom) AND (nbh.boroname = 'Queens' OR nbh.boroname = 'Brooklyn')\n                \"\"\")\n\nall_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")\n\nsub_subway = gpd.read_postgis(query, con=engine)\n\nall_neighbors = gpd.read_postgis(all_nbg, con = engine)\n\n## Plot maps\n\nig, ax = plt.subplots(figsize=(12, 10))\n\nall_neighbors.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')\n\n# Plot subway stations in red\nsub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')\n\n# Add title, legend, and grid\nplt.title('NYC Neighborhoods with Subway Stations in Queens, Brooklyn', fontsize=15)\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n</pre> # Write and execute your SQL query query = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom FROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways   WHERE ST_Intersects(nbh.geom, subways.geom) AND (nbh.boroname = 'Queens' OR nbh.boroname = 'Brooklyn')                 \"\"\")  all_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")  sub_subway = gpd.read_postgis(query, con=engine)  all_neighbors = gpd.read_postgis(all_nbg, con = engine)  ## Plot maps  ig, ax = plt.subplots(figsize=(12, 10))  all_neighbors.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')  # Plot subway stations in red sub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')  # Add title, legend, and grid plt.title('NYC Neighborhoods with Subway Stations in Queens, Brooklyn', fontsize=15) plt.legend() plt.grid(True)  # Show the plot plt.show()   <pre>C:\\Users\\yyang\\AppData\\Local\\Temp\\ipykernel_19008\\1634607323.py:24: UserWarning: Legend does not support handles for PatchCollection instances.\nSee: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler\n  plt.legend()\n</pre> In\u00a0[18]: Copied! <pre># Write and execute your SQL query\nquery = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom\nFROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways  \nWHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname in ('Queens' ,'Brooklyn')\n                \"\"\")\n\nall_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")\n\nsub_subway = gpd.read_postgis(query, con=engine)\n\nall_neighbors = gpd.read_postgis(all_nbg, con = engine)\n\n## Plot maps\n\nig, ax = plt.subplots(figsize=(12, 10))\n\nall_neighbors.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')\n\n# Plot subway stations in red\nsub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')\n\n# Add title, legend, and grid\nplt.title('NYC Neighborhoods with Subway Stations in Queens, Brooklyn', fontsize=15)\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n</pre> # Write and execute your SQL query query = text(\"\"\"SELECT nbh.NAME AS nbh_name, subways.NAME AS subway_name, subways.geom FROM ch05.nyc_neighborhoods nbh, ch05.nyc_subway_stations subways   WHERE ST_Intersects(nbh.geom, subways.geom) AND nbh.boroname in ('Queens' ,'Brooklyn')                 \"\"\")  all_nbg = text(\"SELECT * FROM ch05.nyc_neighborhoods\")  sub_subway = gpd.read_postgis(query, con=engine)  all_neighbors = gpd.read_postgis(all_nbg, con = engine)  ## Plot maps  ig, ax = plt.subplots(figsize=(12, 10))  all_neighbors.plot(ax=ax, color='lightgray', edgecolor='black', alpha=0.5, label='Neighborhoods')  # Plot subway stations in red sub_subway.plot(ax=ax, color='red', markersize=50, label='Subway Stations')  # Add title, legend, and grid plt.title('NYC Neighborhoods with Subway Stations in Queens, Brooklyn', fontsize=15) plt.legend() plt.grid(True)  # Show the plot plt.show()   <pre>C:\\Users\\yyang\\AppData\\Local\\Temp\\ipykernel_19008\\3844934080.py:24: UserWarning: Legend does not support handles for PatchCollection instances.\nSee: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler\n  plt.legend()\n</pre>"},{"location":"Lectures/Week05/Student_spatial_relationship/#Add-the-passworkd-to-User-Variabels-for-Administrator","title":"Add the passworkd to User Variabels for Administrator\u00b6","text":"<ul> <li>System Properties</li> <li>Envrionment Variables</li> <li>New</li> <li>Variable name: SQL_PASSWORD ; Variable value: the password for postgresql</li> </ul>"},{"location":"Lectures/Week05/Student_spatial_relationship/#Select-Ten-Features-FROM-nyc_neighborhoods","title":"Select Ten Features FROM nyc_neighborhoods\u00b6","text":""},{"location":"Lectures/Week05/Student_spatial_relationship/#Select-All-features-from-nyc_neighborhoods","title":"Select All features from nyc_neighborhoods\u00b6","text":""},{"location":"Lectures/Week05/Student_spatial_relationship/#ST_Instersects","title":"ST_Instersects\u00b6","text":"<p>Identify all subway stations that intersect with neighborhoods = 'Manhattan'</p>"},{"location":"Lectures/Week05/Student_spatial_relationship/#Plot-neighborhoods-and-Manhattan","title":"Plot neighborhoods and Manhattan\u00b6","text":""},{"location":"Lectures/Week05/Student_spatial_relationship/#Exercise-1:-Select-subway-stations-that-locate-in-neighborhoods-in-'Queens',-'Brooklyn'","title":"Exercise 1: Select subway stations that locate in neighborhoods in 'Queens', 'Brooklyn'\u00b6","text":""},{"location":"Lectures/Week06/Instructor_Dynamic_SQL/","title":"Instructor Dynamic SQL","text":"In\u00a0[9]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[10]: Copied! <pre>host = 'localhost'\ndatabase = 'spatialdata'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatialdata' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') In\u00a0[11]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n\nengine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"  engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() Out[11]: <pre>['spatial_ref_sys', 'nyc_census_blocks_2000', 'nyc_subway_stations']</pre> In\u00a0[12]: Copied! <pre>function_sql = \"\"\"\nCREATE OR REPLACE FUNCTION dynamic_subway_filter(\n    schema_name TEXT,   -- Schema name\n    table_name TEXT,    -- Table name\n\n\tschema_name02 TEXT,\n\ttable_name02 TEXT, \n\t\n    column_name TEXT, -- Column name to filter\n    subway_color TEXT, -- Value to filter by\n\tbuffer_size NUMERIC\n)\nRETURNS TABLE (\n    id double precision,\n    name character varying(200),\n\tgeom geometry(Point,26918))\n\t\nAS \n$$\nDECLARE\n    sql_query TEXT;  -- Stores the dynamic SQL query\nBEGIN\n    -- Construct the dynamic SQL statement\n    sql_query := format(\n        'SELECT street.id, street.name, street.geom\n        FROM %I.%I AS street\n        JOIN %I.%I AS subway\n        ON ST_Intersects(street.geom, ST_Buffer(subway.geom, %L))\n        WHERE subway.%I = %L', \n        schema_name, table_name,schema_name02,table_name02,buffer_size, column_name, subway_color\n    );\n\n    -- Execute the dynamic query and return results\n    RETURN QUERY EXECUTE sql_query;\nEND;\n$$\nLANGUAGE plpgsql;\n\"\"\"\n\nwith engine.connect() as conn:\n    conn.execute(text(function_sql))\n    conn.commit()\n\nsql_text = \"\"\"select * from dynamic_subway_filter('ch05','streets', 'ch05', 'subway', 'color', 'BLUE', 100)\"\"\"\n\noutcome_street = gpd.read_postgis(sql_text, con=engine)\n\n## get neighborhoods\nnbh_text = text(\"\"\" SELECT * FROM ch05.neighborhoods\"\"\")\nall_nbh = gpd.read_postgis(nbh_text, con = engine)\n\n## get outcome subway\nsubway_text = text(\"\"\" SELECT geom \n                      FROM ch05.subway\n                      where color = 'BLUE' \"\"\")\noutcome_subway = gpd.read_postgis(subway_text, con = engine)\n\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nall_nbh.plot(ax=ax,facecolor = 'none',)\noutcome_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\noutcome_street.plot(ax=ax, color = 'BLUE',edgecolor='black')\n\n\nplt.title('NYC Streets with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> function_sql = \"\"\" CREATE OR REPLACE FUNCTION dynamic_subway_filter(     schema_name TEXT,   -- Schema name     table_name TEXT,    -- Table name  \tschema_name02 TEXT, \ttable_name02 TEXT,  \t     column_name TEXT, -- Column name to filter     subway_color TEXT, -- Value to filter by \tbuffer_size NUMERIC ) RETURNS TABLE (     id double precision,     name character varying(200), \tgeom geometry(Point,26918)) \t AS  $$ DECLARE     sql_query TEXT;  -- Stores the dynamic SQL query BEGIN     -- Construct the dynamic SQL statement     sql_query := format(         'SELECT street.id, street.name, street.geom         FROM %I.%I AS street         JOIN %I.%I AS subway         ON ST_Intersects(street.geom, ST_Buffer(subway.geom, %L))         WHERE subway.%I = %L',          schema_name, table_name,schema_name02,table_name02,buffer_size, column_name, subway_color     );      -- Execute the dynamic query and return results     RETURN QUERY EXECUTE sql_query; END; $$ LANGUAGE plpgsql; \"\"\"  with engine.connect() as conn:     conn.execute(text(function_sql))     conn.commit()  sql_text = \"\"\"select * from dynamic_subway_filter('ch05','streets', 'ch05', 'subway', 'color', 'BLUE', 100)\"\"\"  outcome_street = gpd.read_postgis(sql_text, con=engine)  ## get neighborhoods nbh_text = text(\"\"\" SELECT * FROM ch05.neighborhoods\"\"\") all_nbh = gpd.read_postgis(nbh_text, con = engine)  ## get outcome subway subway_text = text(\"\"\" SELECT geom                        FROM ch05.subway                       where color = 'BLUE' \"\"\") outcome_subway = gpd.read_postgis(subway_text, con = engine)   fig, ax = plt.subplots(figsize=(12, 10))  all_nbh.plot(ax=ax,facecolor = 'none',) outcome_subway.plot(ax=ax, facecolor = 'none',edgecolor='black') outcome_street.plot(ax=ax, color = 'BLUE',edgecolor='black')   plt.title('NYC Streets with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True) <pre>C:\\Users\\Administrator\\AppData\\Local\\Temp\\ipykernel_47700\\95899795.py:67: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  plt.legend()\n</pre>"},{"location":"Lectures/Week06/Student_Dynamic_SQL/","title":"Student Dynamic SQL","text":"Week 6: Dynamic SQL      In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>host = 'localhost'\ndatabase = 'spatialdata'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatialdata' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') In\u00a0[\u00a0]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n\nengine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"  engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() <ul> <li><p>with engine.connect() as conn:</p> <ul> <li>Establishes a connection to the database using engine.connect().</li> <li>Uses a with statement to ensure the connection automatically closes after execution.</li> <li>conn.execute(text(function_sql))</li> </ul> </li> <li><p>Executes the SQL command stored in function_sql.</p> <ul> <li>The text(function_sql) ensures that the SQL is properly formatted for execution.</li> <li>This step creates or replaces the function in PostgreSQL.</li> <li>conn.commit()</li> </ul> </li> <li><p>Commits the transaction to apply changes to the database.</p> <ul> <li>Ensures the function is saved in PostgreSQL.</li> <li>Without this, the function definition may not persist.</li> </ul> </li> </ul> In\u00a0[\u00a0]: Copied! <pre>function_sql = \"\"\"\n\n\"\"\"\n\nwith engine.connect() as conn:\n    conn.execute(text(function_sql))\n    conn.commit()\n\nsql_text = \"\"\"select * from dynamic_subway_filter('ch05','streets', 'ch05', 'subway', 'color', 'BLUE', 100)\"\"\"\n\noutcome_street = gpd.read_postgis(sql_text, con=engine)\n\n## get neighborhoods\nnbh_text = text(\"\"\" SELECT * FROM ch05.neighborhoods\"\"\")\nall_nbh = gpd.read_postgis(nbh_text, con = engine)\n\n## get outcome subway\nsubway_text = text(\"\"\" SELECT geom \n                      FROM ch05.subway\n                      where color = 'BLUE' \"\"\")\noutcome_subway = gpd.read_postgis(subway_text, con = engine)\n\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nall_nbh.plot(ax=ax,facecolor = 'none',)\noutcome_subway.plot(ax=ax, facecolor = 'none',edgecolor='black')\noutcome_street.plot(ax=ax, color = 'BLUE',edgecolor='black')\n\n\nplt.title('NYC Streets with Subway Stations in Manhattan', fontsize=15)\nplt.legend()\nplt.grid(True)\n</pre> function_sql = \"\"\"  \"\"\"  with engine.connect() as conn:     conn.execute(text(function_sql))     conn.commit()  sql_text = \"\"\"select * from dynamic_subway_filter('ch05','streets', 'ch05', 'subway', 'color', 'BLUE', 100)\"\"\"  outcome_street = gpd.read_postgis(sql_text, con=engine)  ## get neighborhoods nbh_text = text(\"\"\" SELECT * FROM ch05.neighborhoods\"\"\") all_nbh = gpd.read_postgis(nbh_text, con = engine)  ## get outcome subway subway_text = text(\"\"\" SELECT geom                        FROM ch05.subway                       where color = 'BLUE' \"\"\") outcome_subway = gpd.read_postgis(subway_text, con = engine)   fig, ax = plt.subplots(figsize=(12, 10))  all_nbh.plot(ax=ax,facecolor = 'none',) outcome_subway.plot(ax=ax, facecolor = 'none',edgecolor='black') outcome_street.plot(ax=ax, color = 'BLUE',edgecolor='black')   plt.title('NYC Streets with Subway Stations in Manhattan', fontsize=15) plt.legend() plt.grid(True)"},{"location":"Lectures/Week07/Week07_lecture_geotagging/","title":"Week07 lecture geotagging","text":"In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\n</pre> import matplotlib.pyplot as plt from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd In\u00a0[\u00a0]: Copied! <pre>host = 'localhost'\ndatabase = 'spatial'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatial' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD') In\u00a0[\u00a0]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\" In\u00a0[\u00a0]: Copied! <pre>engine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() In\u00a0[\u00a0]: Copied! <pre>text_road = \"\"\" SELECT * FROM ch09.road\"\"\"\nroad = gpd.read_postgis(text_road, con=engine)\n\nfig, ax = plt.subplots(figsize=(12, 10))\nroad.plot(ax=ax, color = 'grey')\n</pre> text_road = \"\"\" SELECT * FROM ch09.road\"\"\" road = gpd.read_postgis(text_road, con=engine)  fig, ax = plt.subplots(figsize=(12, 10)) road.plot(ax=ax, color = 'grey') In\u00a0[\u00a0]: Copied! <pre>text_road = \"\"\" SELECT * FROM ch09.road\"\"\"\nroad = gpd.read_postgis(text_road, con=engine)\n\ntext_land = \"\"\" SELECT * FROM ch09.land\"\"\"\nland = gpd.read_postgis(text_land, con=engine)\n# Get bounding box of land to zoom in\nxmin, ymin, xmax, ymax = land.total_bounds\n\nfig, ax = plt.subplots(figsize=(12, 10))\nbuffer = 20000\nax.set_xlim(xmin -  buffer, xmax + buffer)\nax.set_ylim(ymin - buffer, ymax + buffer)\n\nland.plot(ax=ax, color = 'blue')\nroad.plot(ax=ax, color = 'grey')\n</pre> text_road = \"\"\" SELECT * FROM ch09.road\"\"\" road = gpd.read_postgis(text_road, con=engine)  text_land = \"\"\" SELECT * FROM ch09.land\"\"\" land = gpd.read_postgis(text_land, con=engine) # Get bounding box of land to zoom in xmin, ymin, xmax, ymax = land.total_bounds  fig, ax = plt.subplots(figsize=(12, 10)) buffer = 20000 ax.set_xlim(xmin -  buffer, xmax + buffer) ax.set_ylim(ymin - buffer, ymax + buffer)  land.plot(ax=ax, color = 'blue') road.plot(ax=ax, color = 'grey') In\u00a0[\u00a0]: Copied! <pre>text_snap_point= \"\"\"SELECT DISTINCT ON (land.pid)\nland.addr_num || ' ' || full_str AS parcel,\nroad.road_name AS road,\nST_ClosestPoint(land.geom,road.geom) As geom\n\nFROM ch09.land AS land INNER JOIN ch09.road AS road\nON ST_DWithin(land.geom,road.geom,20.0)\nORDER BY land.pid, ST_Distance(land.geom,road.geom);\"\"\"\n\nsnap_point = gpd.read_postgis(text_snap_point, con=engine)\n\nprint(snap_point.head(n = 5))\n\ntext_land = \"\"\" SELECT * FROM ch09.land\"\"\"\nland = gpd.read_postgis(text_land, con=engine)\nfig, ax = plt.subplots(figsize=(12, 10))\n\nsnap_point.plot(ax=ax, color = 'red')\nland.plot(ax=ax, color = 'black')\n</pre> text_snap_point= \"\"\"SELECT DISTINCT ON (land.pid) land.addr_num || ' ' || full_str AS parcel, road.road_name AS road, ST_ClosestPoint(land.geom,road.geom) As geom  FROM ch09.land AS land INNER JOIN ch09.road AS road ON ST_DWithin(land.geom,road.geom,20.0) ORDER BY land.pid, ST_Distance(land.geom,road.geom);\"\"\"  snap_point = gpd.read_postgis(text_snap_point, con=engine)  print(snap_point.head(n = 5))  text_land = \"\"\" SELECT * FROM ch09.land\"\"\" land = gpd.read_postgis(text_land, con=engine) fig, ax = plt.subplots(figsize=(12, 10))  snap_point.plot(ax=ax, color = 'red') land.plot(ax=ax, color = 'black') In\u00a0[\u00a0]: Copied! <pre>text_cluster = \"\"\"SELECT land.pid, land.geom,\nland.addr_num || ' ' || full_str AS address,\nST_ClusterKMeans(land.geom, 4) OVER() AS kcluster,\nST_ClusterDBSCAN(land.geom, 15, 2) OVER() AS dcluster\nFROM ch09.land AS land;\"\"\"\n\ncluster = gpd.read_postgis(text_cluster, con = engine)\n\n# Plot the clusters based on kcluster column\nfig, ax = plt.subplots(figsize=(10, 8))\ncluster.plot(column=\"kcluster\", cmap=\"tab10\", edgecolor=\"none\", alpha=0.75, ax=ax)\n</pre> text_cluster = \"\"\"SELECT land.pid, land.geom, land.addr_num || ' ' || full_str AS address, ST_ClusterKMeans(land.geom, 4) OVER() AS kcluster, ST_ClusterDBSCAN(land.geom, 15, 2) OVER() AS dcluster FROM ch09.land AS land;\"\"\"  cluster = gpd.read_postgis(text_cluster, con = engine)  # Plot the clusters based on kcluster column fig, ax = plt.subplots(figsize=(10, 8)) cluster.plot(column=\"kcluster\", cmap=\"tab10\", edgecolor=\"none\", alpha=0.75, ax=ax) In\u00a0[\u00a0]: Copied! <pre># Plot the clusters based on kcluster column\nfig, ax = plt.subplots(figsize=(10, 8))\ncluster.plot(column=\"dcluster\", cmap=\"tab10\", edgecolor=\"none\", alpha=0.75, ax=ax)\n</pre> # Plot the clusters based on kcluster column fig, ax = plt.subplots(figsize=(10, 8)) cluster.plot(column=\"dcluster\", cmap=\"tab10\", edgecolor=\"none\", alpha=0.75, ax=ax)"},{"location":"Lectures/Week07/Week07_lecture_geotagging/#Streets-in-MA","title":"Streets in MA\u00b6","text":""},{"location":"Lectures/Week07/Week07_lecture_geotagging/#Parcel","title":"Parcel\u00b6","text":""},{"location":"Lectures/Week07/Week07_lecture_geotagging/#Snap-points-on-the-road-to-Parcel","title":"Snap points on the road to Parcel\u00b6","text":""},{"location":"Lectures/Week07/Week07_lecture_geotagging/#Clustering:-k_means","title":"Clustering: k_means\u00b6","text":""},{"location":"Lectures/Week07/Week07_lecture_geotagging/#DBScan-clustering","title":"DBScan clustering\u00b6","text":""},{"location":"Lectures/Week09/Week09_SQL_Tutorial/","title":"Week09 SQL Tutorial","text":""},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#Week-9:-SQL-for-Spatial-Data-Processing","title":"Week 9: SQL for Spatial Data Processing\u00b6","text":"<p>This tutorial covers key SQL elements for spatial data processing, focusing on:</p> <ol> <li>Date and Time Functions</li> <li>Type Casting and Conversion</li> <li>Spatial Functions (PostGIS)</li> <li>Aggregation and Grouping</li> <li>Creating New Tables from Queries</li> </ol> <p>We'll explore these concepts using examples from our lecture.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#1.-Date-and-Time-Functions","title":"1. Date and Time Functions\u00b6","text":"<p>PostgreSQL provides powerful functions for working with date and time data. Let's explore some key functions:</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#1.1-DATE_TRUNC","title":"1.1 DATE_TRUNC\u00b6","text":"<p><code>DATE_TRUNC</code> truncates a timestamp to a specified precision (year, month, day, hour, minute, etc.).</p> <pre>SELECT date_trunc('minute', TIMESTAMP '2009-07-18 04:30:00-04');\n</pre> <p>This returns: <code>2009-07-18 04:30:00-04</code></p> <p>If we had used <code>'hour'</code> instead of <code>'minute'</code>, it would return: <code>2009-07-18 04:00:00-04</code></p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#1.2-DATE_PART","title":"1.2 DATE_PART\u00b6","text":"<p><code>DATE_PART</code> extracts a specific component (year, month, day, hour, minute, etc.) from a timestamp.</p> <pre>SELECT DATE_PART('minute', TIMESTAMP '2009-07-18 04:31:00-04');\n</pre> <p>This returns: <code>31</code> (the minute component of the timestamp)</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#2.-Type-Casting-and-Conversion","title":"2. Type Casting and Conversion\u00b6","text":"<p>PostgreSQL allows converting between different data types using the <code>CAST</code> function or the <code>::</code> operator.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#2.1-Basic-Casting","title":"2.1 Basic Casting\u00b6","text":"<pre>-- Cast DATE_PART result to integer\nSELECT CAST(DATE_PART('minute', TIMESTAMP '2009-07-18 04:31:00-04') AS integer);\n</pre> <p>This returns: <code>31</code> (as an integer, not a numeric type)</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#2.2-String-Concatenation-and-Interval-Casting","title":"2.2 String Concatenation and Interval Casting\u00b6","text":"<p>The <code>||</code> operator concatenates strings, and we can cast strings to intervals:</p> <pre>SELECT CAST(3 || ' minutes' AS interval);\n</pre> <p>This returns: <code>00:03:00</code> (a 3-minute interval)</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#3.-Mathematical-Functions","title":"3. Mathematical Functions\u00b6","text":"<p>PostgreSQL provides various mathematical functions for data processing.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#3.1-Modulo-Operation-(MOD)","title":"3.1 Modulo Operation (MOD)\u00b6","text":"<p>The <code>MOD</code> function returns the remainder of a division operation:</p> <pre>SELECT mod(CAST(DATE_PART('minute', TIMESTAMP '2009-07-18 04:30:00-04') AS integer), 15);\n</pre> <p>This returns: <code>0</code> (because 30 divided by 15 has a remainder of 0)</p> <p>If we used <code>04:31:00</code> instead, it would return: <code>1</code> (because 31 divided by 15 has a remainder of 1)</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#4.-Spatial-Functions-(PostGIS)","title":"4. Spatial Functions (PostGIS)\u00b6","text":"<p>PostGIS extends PostgreSQL with spatial functions for working with geographic data.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#4.1-ST_MakeLine","title":"4.1 ST_MakeLine\u00b6","text":"<p><code>ST_MakeLine</code> creates a LineString from Point geometries:</p> <pre>SELECT ST_MakeLine(geom ORDER BY time) AS geom\nFROM ch11.aussie_track_points\nGROUP BY track_period;\n</pre> <p>This creates a line by connecting points in order of their timestamp.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#4.2-ST_Union","title":"4.2 ST_Union\u00b6","text":"<p><code>ST_Union</code> combines multiple geometries into a single geometry:</p> <pre>-- Aggregate city geometries\nCREATE TABLE ch11.boroughs_city AS\nSELECT ST_Union(geom) AS geom\nFROM ch11.boroughs;\n</pre> <p>The <code>ST_Union</code> function can also take a tolerance parameter for simplification:</p> <pre>-- New York City unified with 500-foot grid\nCREATE TABLE ch11.boroughs_citi_500 AS \nSELECT ST_Union(geom, 500) AS geom\nFROM ch11.boroughs;\n</pre>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#4.3-ST_NPoints-and-ST_NumGeometries","title":"4.3 ST_NPoints and ST_NumGeometries\u00b6","text":"<p><code>ST_NPoints</code> counts the number of points in a geometry:</p> <pre>SELECT ST_NPoints(geom) AS np\nFROM ch11.aussie_run;\n</pre> <p><code>ST_NumGeometries</code> counts the number of geometries in a multi-geometry:</p> <pre>SELECT ST_NumGeometries(ST_Union(geom)) AS num_poly_after\nFROM ch11.cities\nGROUP BY city;\n</pre>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#4.4-ST_Length","title":"4.4 ST_Length\u00b6","text":"<p><code>ST_Length</code> calculates the length of a LineString. When used with <code>::geography</code> casting, it returns the length in meters:</p> <pre>SELECT CAST(ST_Length(geom::geography) AS integer) AS dist_m\nFROM ch11.aussie_run;\n</pre>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#4.5-ST_Touches","title":"4.5 ST_Touches\u00b6","text":"<p><code>ST_Touches</code> checks if two geometries share a boundary but don't overlap:</p> <pre>SELECT a.city, a.gid AS gid_1, b.gid AS gid_2\nFROM ch11.cities a\nJOIN ch11.cities b \nON a.city = b.city  -- Same city name\nAND a.gid &lt; b.gid  -- Avoid self-join and duplicate pairs\nAND ST_Touches(a.geom, b.geom);  -- Check if they share a boundary\n</pre>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#5.-Aggregation-and-Grouping","title":"5. Aggregation and Grouping\u00b6","text":"<p>SQL provides powerful aggregation functions and grouping capabilities.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#5.1-Basic-Aggregation-Functions","title":"5.1 Basic Aggregation Functions\u00b6","text":"<pre>SELECT \n    MIN(time) AS t_start, \n    MAX(time) AS t_end\nFROM ch11.aussie_track_points\nGROUP BY track_period;\n</pre> <p>This finds the earliest and latest timestamps for each track period.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#5.2-Complex-Grouping-with-Calculated-Fields","title":"5.2 Complex Grouping with Calculated Fields\u00b6","text":"<p>We can group by calculated fields, not just simple columns:</p> <pre>SELECT \n    DATE_TRUNC('minute', time) - \n        CAST(\n            mod(CAST(DATE_PART('minute', time) AS integer), 15) || ' minutes' AS interval\n        ) AS track_period,\n    MIN(time) AS t_start, \n    MAX(time) AS t_end,\n    ST_MakeLine(geom ORDER BY time) AS geom\nFROM ch11.aussie_track_points\nGROUP BY track_period;\n</pre> <p>This groups track points into 15-minute intervals by:</p> <ol> <li>Truncating the timestamp to the minute</li> <li>Calculating the remainder when dividing the minute by 15</li> <li>Subtracting that remainder to get the start of the 15-minute interval</li> </ol>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#5.3-HAVING-Clause","title":"5.3 HAVING Clause\u00b6","text":"<p>The <code>HAVING</code> clause filters groups after aggregation:</p> <pre>SELECT city, COUNT(city) AS num_records,\nSUM(ST_NumGeometries(geom)) AS numpoly_before,\nST_NumGeometries(ST_Union(geom)) AS num_poly_after\nFROM ch11.cities\nGROUP BY city\nHAVING COUNT(city) &gt; 1;\n</pre> <p>This finds cities with multiple records and shows the before/after polygon counts when merged.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#6.-Creating-New-Tables-from-Queries","title":"6. Creating New Tables from Queries\u00b6","text":"<p>PostgreSQL allows creating new tables from query results using the <code>INTO</code> clause or <code>CREATE TABLE AS</code> statement.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#6.1-Using-INTO-Clause","title":"6.1 Using INTO Clause\u00b6","text":"<pre>SELECT \n    DATE_TRUNC('minute',time) -\n        CAST(\n            mod(\n                CAST(DATE_PART('minute',time) AS integer),15\n            ) ||' minutes' AS interval\n        ) AS track_period,\n    MIN(time) AS t_start, \n    MAX(time) AS t_end, \n    ST_MakeLine(geom ORDER BY time) AS geom  \nINTO ch11.aussie_run\nFROM ch11.aussie_track_points\nGROUP BY track_period;\n</pre> <p>This creates a new table <code>ch11.aussie_run</code> with the results of the query.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#6.2-Using-CREATE-TABLE-AS","title":"6.2 Using CREATE TABLE AS\u00b6","text":"<pre>CREATE TABLE ch11.cities_merged AS\nSELECT \n    city,\n    COUNT(city) AS num_records,\n    SUM(ST_NumGeometries(geom)) AS numpoly_before,\n    ST_NumGeometries(ST_Union(geom)) AS num_poly_after,\n    ST_Union(geom) AS merged_geom\nFROM ch11.cities\nGROUP BY city\nHAVING COUNT(city) &gt; 0;\n</pre> <p>This creates a new table <code>ch11.cities_merged</code> with the results of the query.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#7.-Practical-Example:-Tracking-Data-Analysis","title":"7. Practical Example: Tracking Data Analysis\u00b6","text":"<p>Let's put everything together with a practical example from our lecture. This example processes GPS tracking data to create line segments for 15-minute intervals and analyze the results.</p>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#7.1-Creating-Track-Segments","title":"7.1 Creating Track Segments\u00b6","text":"<pre>-- Create a new table with track segments\nSELECT \n    DATE_TRUNC('minute',time) -\n        CAST(\n            mod(\n                CAST(DATE_PART('minute',time) AS integer),15\n            ) ||' minutes' AS interval\n        ) AS track_period,\n    MIN(time) AS t_start, \n    MAX(time) AS t_end, \n    ST_MakeLine(geom ORDER BY time) AS geom  \nINTO ch11.aussie_run\nFROM ch11.aussie_track_points\nGROUP BY track_period;\n</pre> <p>This query:</p> <ol> <li>Groups track points into 15-minute intervals</li> <li>Finds the start and end times for each interval</li> <li>Creates a line geometry connecting the points in time order</li> <li>Saves the results to a new table</li> </ol>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#7.2-Analyzing-the-Results","title":"7.2 Analyzing the Results\u00b6","text":"<pre>SELECT \n    CAST(track_period AS timestamp),\n    CAST(t_start AS timestamp) AS t_start,    \n    CAST(t_end AS timestamp) AS t_end, \n    ST_NPoints(geom) AS np, \n    CAST(ST_Length(geom::geography) AS integer) AS dist_m, \n    (t_end - t_start) AS dur               \nFROM ch11.aussie_run;\n</pre> <p>This query analyzes the track segments by:</p> <ol> <li>Converting timestamps to a readable format</li> <li>Counting the number of points in each line segment</li> <li>Calculating the distance traveled in meters</li> <li>Computing the duration of each segment</li> </ol>"},{"location":"Lectures/Week09/Week09_SQL_Tutorial/#Summary","title":"Summary\u00b6","text":"<p>In this tutorial, we've covered key SQL elements for spatial data processing:</p> <ol> <li>Date and Time Functions: <code>DATE_TRUNC</code>, <code>DATE_PART</code></li> <li>Type Casting: <code>CAST</code>, string concatenation with <code>||</code></li> <li>Mathematical Functions: <code>MOD</code></li> <li>Spatial Functions: <code>ST_MakeLine</code>, <code>ST_Union</code>, <code>ST_NPoints</code>, <code>ST_NumGeometries</code>, <code>ST_Length</code>, <code>ST_Touches</code></li> <li>Aggregation: <code>MIN</code>, <code>MAX</code>, <code>COUNT</code>, <code>SUM</code>, <code>GROUP BY</code>, <code>HAVING</code></li> <li>Table Creation: <code>INTO</code>, <code>CREATE TABLE AS</code></li> </ol> <p>These elements are powerful tools for processing and analyzing spatial data in PostgreSQL with PostGIS.</p>"},{"location":"Lectures/Week09/lecture_Week09/","title":"lecture Week09","text":"In\u00a0[7]: Copied! <pre>import matplotlib.pyplot as plt\nimport matplotlib.colors as mcolors\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\nfrom sqlalchemy import text\nimport os\nimport geopandas as gpd\nimport plotly\n</pre> import matplotlib.pyplot as plt import matplotlib.colors as mcolors from sqlalchemy import create_engine from sqlalchemy import inspect from sqlalchemy import text import os import geopandas as gpd import plotly  In\u00a0[8]: Copied! <pre>host = 'localhost'\ndatabase = 'spatial'\nuser = 'postgres'\nport = '5432'\npassword = os.getenv('SQL_PASSWORD')\n</pre> host = 'localhost' database = 'spatial' user = 'postgres' port = '5432' password = os.getenv('SQL_PASSWORD')  In\u00a0[9]: Copied! <pre>connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n\nengine = create_engine(connection_string)\ninsp = inspect(engine)\ninsp.get_table_names()\n</pre> connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"  engine = create_engine(connection_string) insp = inspect(engine) insp.get_table_names() Out[9]: <pre>['spatial_ref_sys']</pre> In\u00a0[4]: Copied! <pre>citi_text = \"\"\" select * from ch11.aussie_track_points\n\"\"\"\n\ntracks_points = gpd.read_postgis(citi_text, con=engine)\n</pre> citi_text = \"\"\" select * from ch11.aussie_track_points \"\"\"  tracks_points = gpd.read_postgis(citi_text, con=engine) In\u00a0[5]: Copied! <pre>filtered_tracks_points = tracks_points[tracks_points.geometry.x &lt; 153]\n</pre> filtered_tracks_points = tracks_points[tracks_points.geometry.x &lt; 153]   In\u00a0[13]: Copied! <pre># Modern UI visualization using Matplotlib with a modern style\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nfrom matplotlib.colors import LinearSegmentedColormap\nimport numpy as np\n\n# Set a modern style for matplotlib\nplt.style.use('seaborn-v0_8-whitegrid')\n\n# Create a figure with a specific size for better visualization\nfig, ax = plt.subplots(figsize=(12, 8), dpi=100)\n\n# Extract coordinates from the geometry column\nx = [point.x for point in filtered_tracks_points.geometry]\ny = [point.y for point in filtered_tracks_points.geometry]\n\n# Create a modern color gradient\ncolors = [\"#2196F3\", \"#03A9F4\", \"#00BCD4\", \"#009688\"]\nn_bins = 100\ncmap_name = 'modern_blue'\ncm = LinearSegmentedColormap.from_list(cmap_name, colors, N=n_bins)\n\n# Create a scatter plot with modern styling\nscatter = ax.scatter(\n    x, y,\n    c=np.arange(len(x)),  # Color points by sequence\n    cmap=cm,\n    alpha=0.8,\n    s=50,  # Marker size\n    edgecolor='white',\n    linewidth=0.5\n)\n\n# Add a colorbar for visual reference\ncbar = plt.colorbar(scatter, ax=ax, pad=0.02)\ncbar.set_label('Point Sequence', fontsize=12, fontweight='bold')\n\n# Set title and labels with modern typography\nax.set_title('Track Points - Modern Visualization', fontsize=20, fontweight='bold', pad=20)\nax.set_xlabel('Longitude', fontsize=14, fontweight='bold')\nax.set_ylabel('Latitude', fontsize=14, fontweight='bold')\n\n# Customize grid\nax.grid(True, linestyle='--', alpha=0.7)\n\n# Customize spines\nfor spine in ax.spines.values():\n    spine.set_visible(True)\n    spine.set_color('#CCCCCC')\n    spine.set_linewidth(0.5)\n\n# Tight layout for better spacing\nplt.tight_layout()\n\n# Show the plot\nplt.show()\n</pre> # Modern UI visualization using Matplotlib with a modern style import matplotlib.pyplot as plt import matplotlib.cm as cm from matplotlib.colors import LinearSegmentedColormap import numpy as np  # Set a modern style for matplotlib plt.style.use('seaborn-v0_8-whitegrid')  # Create a figure with a specific size for better visualization fig, ax = plt.subplots(figsize=(12, 8), dpi=100)  # Extract coordinates from the geometry column x = [point.x for point in filtered_tracks_points.geometry] y = [point.y for point in filtered_tracks_points.geometry]  # Create a modern color gradient colors = [\"#2196F3\", \"#03A9F4\", \"#00BCD4\", \"#009688\"] n_bins = 100 cmap_name = 'modern_blue' cm = LinearSegmentedColormap.from_list(cmap_name, colors, N=n_bins)  # Create a scatter plot with modern styling scatter = ax.scatter(     x, y,     c=np.arange(len(x)),  # Color points by sequence     cmap=cm,     alpha=0.8,     s=50,  # Marker size     edgecolor='white',     linewidth=0.5 )  # Add a colorbar for visual reference cbar = plt.colorbar(scatter, ax=ax, pad=0.02) cbar.set_label('Point Sequence', fontsize=12, fontweight='bold')  # Set title and labels with modern typography ax.set_title('Track Points - Modern Visualization', fontsize=20, fontweight='bold', pad=20) ax.set_xlabel('Longitude', fontsize=14, fontweight='bold') ax.set_ylabel('Latitude', fontsize=14, fontweight='bold')  # Customize grid ax.grid(True, linestyle='--', alpha=0.7)  # Customize spines for spine in ax.spines.values():     spine.set_visible(True)     spine.set_color('#CCCCCC')     spine.set_linewidth(0.5)  # Tight layout for better spacing plt.tight_layout()  # Show the plot plt.show() In\u00a0[\u00a0]: Copied! <pre># Create a plot of the tracks_points\nfiltered_tracks_points.plot(marker='o', color='blue', markersize=5)\n\n# Add title and labels\nplt.title(\"Track Points\")\nplt.xlabel(\"Longitude\")\nplt.ylabel(\"Latitude\")\nplt.grid(True)\nplt.show()\n</pre> # Create a plot of the tracks_points filtered_tracks_points.plot(marker='o', color='blue', markersize=5)  # Add title and labels plt.title(\"Track Points\") plt.xlabel(\"Longitude\") plt.ylabel(\"Latitude\") plt.grid(True) plt.show()"},{"location":"software/Anaconda/","title":"Anaconda","text":"<pre># check python location\nwhere python\n\n# check python version \npython -V\n</pre>"},{"location":"software/Anaconda/#Anaconda","title":"Anaconda\u00b6","text":"<p>Anaconda Distribution is a popular platform that contains</p> <ul> <li>conda - a package and environment manager for your command line interface</li> <li>Over 300 automaticall-installed packages</li> </ul>"},{"location":"software/Anaconda/#Installation","title":"Installation\u00b6","text":"<p>To install Anaconda, download the installer from the Anaconda website. The installer will ask you to accept the license agreement, choose the installation directory.</p>"},{"location":"software/Anaconda/#Usage","title":"Usage\u00b6","text":"<p>After installing Anaconda, you can open the Anaconda Prompt to chekc your python version</p>"},{"location":"software/Anaconda/#check-python","title":"check python\u00b6","text":""},{"location":"software/Anaconda/#Setting-up-virtual-environment","title":"Setting up virtual environment\u00b6","text":""},{"location":"software/Anaconda/#Create-a-virtual-environment","title":"Create a virtual environment\u00b6","text":"<p>Right click the Anaconda prompt and Run as Administrator (This step will ensure that your package is installed in Anaconda/env folder)</p> <p>Create a virtual environment named as 'np' with python version 3.9</p> <pre>conda create -n np python=3.9\n</pre>"},{"location":"software/Anaconda/#List-virtual-environment","title":"List virtual environment\u00b6","text":"<p>now if you list virgual envionment, you can see the virtual environment that you just create</p> <pre>conda env list\n</pre>"},{"location":"software/Anaconda/#Activate-virtual-environment","title":"Activate virtual environment\u00b6","text":"<p>if you virtual environment named as 'arcgis_python'</p> <pre>activate np\n</pre>"},{"location":"software/Anaconda/#Install-packages-(e.g.,-numpy)","title":"Install packages (e.g., numpy)\u00b6","text":"<pre>conda install numpy\n</pre>"},{"location":"software/Anaconda/#Remove-a-virtual-environmen-named-'np'","title":"Remove a virtual environmen named 'np'\u00b6","text":"<pre>conda remove -n np --all -y\n</pre>"},{"location":"software/ArcGISPro/","title":"ArcGIS Pro","text":"In\u00a0[\u00a0]: Copied!"},{"location":"software/ArcGISPro/#Set-up-ArcGIS-Pro-Account","title":"Set up ArcGIS Pro Account\u00b6","text":"<p>You should get an invitation email to set up your ArcGIS account</p> <p>The account is composed by your user name and clarku, e.g., yanawu_clarku.</p>"},{"location":"software/ArcGISPro/#Log-in-ArcGIS-Online","title":"Log in ArcGIS Online\u00b6","text":"<ul> <li><p>Log in ArcGIS Online</p> </li> <li><p>At the top of the page, click your username and click My settings.</p> </li> <li><p>On the My settings page, click the Licenses side tab</p> </li> <li><p>Next to ArcGIS Pro, click Download ArcGIS Pro (If you don't see ArcGIS Pro listed under your licensed products, please contact HelpDesk and JoDolan@clarku.edu).</p> </li> <li><p>In the Download ArcGIS Pro window, review the language setting. To download a localized version of ArcGIS Pro, change the setting to the language you want.</p> </li> <li><p>Click Download.</p> </li> </ul> <p>An executable file (.exe) is downloaded to your computer.</p>"},{"location":"software/Git/","title":"Git","text":"<p>Git is a distributed version contol system that is widely used to source code management</p> <pre>## replace Nancy and Nancyteach@example.com with your username and email address.  \ngit config --global user.name \"Nancy\"\ngit config --global user.email \"Nancyteach@example.com\"\n</pre> <p>To check your configuration, run the following command:</p> <pre>git config --global --list\n</pre> <p>To add files to the staging area, run the following command:</p> <pre>git add .\n</pre> <p>To commit the changes, run the following command. Repalce message with your comment to this commit</p> <pre>git commit -m 'message'\n</pre> <p>Push the change from local repository to remote repository</p> <pre>git push\n``\n</pre>"},{"location":"software/Git/#Git-Installation","title":"Git Installation\u00b6","text":"<p>Go to the Git website to download the installer for your operation system</p>"},{"location":"software/Git/#Git-Configuration","title":"Git Configuration\u00b6","text":"<p>You can specify Git configuration settings with the git config command</p> <ul> <li>Setting your username in Git</li> <li>Setting your commit email address</li> </ul>"},{"location":"software/Git/#Git-Usage","title":"Git Usage\u00b6","text":""},{"location":"software/Git/#Clone","title":"Clone\u00b6","text":"<p>Clone a remote repository to loca folder in your machine</p> <pre>git clone &lt;repository_url&gt;\n</pre>"},{"location":"software/Git/#Update-remote-repository","title":"Update remote repository\u00b6","text":"<p>Push change in local repository to remote repository (* do not include empty files (file size is 0) otherwise cause error)</p>"},{"location":"software/Git/#Update-local-repository","title":"Update local repository\u00b6","text":"<p>Pull change from remote repository to local repository</p> <pre>git pull\n</pre>"},{"location":"software/Update_PostgreSQL/","title":"Update PostgreSQL","text":""},{"location":"software/Update_PostgreSQL/#Step-1:-Download-the-Latest-PostgreSQL-Binaries","title":"Step 1: Download the Latest PostgreSQL Binaries\u00b6","text":"<p>Download the new version's installer from the PostgreSQL website.</p> <p>During installation, select a different directory than your current version (e.g., C:\\Program Files\\PostgreSQL\\17).</p>"},{"location":"software/Update_PostgreSQL/#Step-2:-Prepare-for-the-Upgrade","title":"Step 2: Prepare for the Upgrade\u00b6","text":"<p>Stop the PostgreSQL Service (for the current version): Open the Task Manager and stop the postgre service</p> <p></p>"},{"location":"software/Visual-Studio-Code/","title":"Visual Studio Code","text":""},{"location":"software/Visual-Studio-Code/#Visual-Studio-Code","title":"Visual Studio Code\u00b6","text":"<p>It is a free source code editor developed by Microsoft. It supports a wide range of programming languages and frameworks, offering features like syntax highlighting, debuging, integrated Git Control, and extensions to enhance functionality.</p>"},{"location":"software/Visual-Studio-Code/#Installation","title":"Installation\u00b6","text":""},{"location":"software/Visual-Studio-Code/#Install-Visual-Studio-Code","title":"Install Visual Studio Code\u00b6","text":""},{"location":"software/command_prompt/","title":"Command Prompt","text":"<ol> <li>Add path of Anaconda to system environment variable first</li> </ol> <ul> <li>D:\\Anaconda\\condabin (purpose: let system recognize conda)</li> <li>D:\\Anaconda (purpose: set python in Anaconda as default python)</li> </ul> <ol> <li>Open Command Prompt - python</li> <li>After the info about the version cursor transform to &gt;&gt;&gt;</li> <li>Start writing your code</li> <li>Press Enter to get the result</li> </ol>"},{"location":"software/command_prompt/#How-do-I-program-in-Python---Command-Prompt","title":"How do I program in Python - Command Prompt\u00b6","text":""},{"location":"software/command_prompt/#1.-Normal-mode-(Script-Mode)","title":"1. Normal mode (Script Mode)\u00b6","text":""},{"location":"software/command_prompt/#2.-Interactive-mode-(interacting-directly-with-the-interpreter)","title":"2. Interactive mode (interacting directly with the interpreter)\u00b6","text":""}]}